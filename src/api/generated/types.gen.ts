// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

/**
 * Request to add an IP to the allow list
 */
export type AddIpAllowListRequest = {
    /**
     * Optional description for this IP entry
     */
    description?: string | null;
    /**
     * IP address or CIDR range (e.g., "192.168.1.0/24" or "10.0.0.1")
     */
    ip_address: string;
};

export type AddPaymentMethodRequest = {
    set_as_default: boolean;
    stripe_payment_method_id: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type AgentBalanceDataResponse = {
    data: AgentBalanceResponse;
    pagination?: PaginationMeta | null;
};

/**
 * Agent balance response
 */
export type AgentBalanceResponse = {
    agent_wallet: WalletAddress;
    asset: AssetInfo;
    /**
     * Available balance in asset decimal units
     */
    available: number;
    /**
     * Balance in asset decimal units
     */
    balance: number;
    /**
     * Balance in atomic units (for precision)
     */
    balance_atomic: number;
    publisher_id: string;
    publisher_name?: string | null;
    publisher_slug?: string | null;
    /**
     * Reserved balance in asset decimal units
     */
    reserved: number;
    total_queries: number;
};

/**
 * Summary of agent balances across all publishers, grouped by asset
 */
export type AgentBalanceSummary = {
    agent_wallet: WalletAddress;
    /**
     * Individual balances
     */
    balances: Array<AgentBalanceResponse>;
    publishers_used: number;
    total_queries: number;
    /**
     * Total balances per asset
     */
    totals_by_asset: Array<AssetBalanceTotal>;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type AgentBalanceSummaryResponse = {
    data: AgentBalanceSummary;
    pagination?: PaginationMeta | null;
};

/**
 * Source of an agent credit grant (fiat-only, no on-chain deposits)
 */
export type AgentCreditSource = 'fiat_purchase' | 'signup_bonus' | 'payment_method_bonus' | 'daily_claim' | 'referral_reward' | 'admin_grant' | 'promo_code' | 'tier_bonus' | 'refund';

/**
 * Agent template - executable code that runs in compute backends (Daytona, Modal, etc.)
 */
export type AgentTemplate = {
    code: string;
    /**
     * Preferred compute backend (e.g., "daytona", "modal"). If None, uses default.
     */
    compute_backend?: string | null;
    created_at: string;
    deleted_at?: string | null;
    dependencies: unknown;
    description?: string | null;
    failed_invocations: number;
    id: string;
    is_verified: boolean;
    language: TemplateLanguage;
    llm_model?: string | null;
    llm_provider?: string | null;
    name: string;
    price_atomic: number;
    publisher_id: string;
    slug: string;
    successful_invocations: number;
    total_invocations: number;
    total_revenue_atomic: number;
    unique_agents_served: number;
    updated_at: string;
    verified_at?: string | null;
    verified_by?: string | null;
};

/**
 * Summary view of agent template for catalog listing
 */
export type AgentTemplateSummary = {
    description?: string | null;
    id: string;
    is_verified: boolean;
    language: TemplateLanguage;
    name: string;
    price_atomic: number;
    publisher_name?: string | null;
    publisher_slug?: string | null;
    slug: string;
    total_invocations: number;
};

export type AnalyticsQueryParams = {
    /**
     * Number of days to analyze (default: 30)
     */
    days?: number;
};

/**
 * Response struct for API key creation (includes the full key ONCE)
 */
export type ApiKeyCreated = {
    /**
     * The full API key (seren_<key_id>_<secret>) - shown ONCE.
     */
    api_key: string;
    created_at: string;
    expires_at?: string | null;
    id: string;
    key_id: string;
    name: string;
    organization_id: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ApiKeyCreatedResponse = {
    data: ApiKeyCreated;
    pagination?: PaginationMeta | null;
};

/**
 * Response struct for listing API keys (never includes the secret)
 */
export type ApiKeyInfo = {
    created_at: string;
    expires_at?: string | null;
    id: string;
    key_id: string;
    key_prefix: string;
    last_used_at?: string | null;
    name: string;
    organization_id: string;
    revoked_at?: string | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ApiKeysResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<ApiKeyInfo>;
    pagination?: PaginationMeta | null;
};

/**
 * API request body for paid HTTP calls
 */
export type ApiRequestBody = {
    /**
     * Optional asset id to pay with (defaults to publisher primary asset)
     */
    asset_id?: string | null;
    /**
     * Optional JSON body to send
     */
    body?: unknown;
    /**
     * Optional estimated rows for pricing (default: 1000)
     */
    estimated_rows?: number | null;
    /**
     * Optional request headers (will not override publisher headers)
     */
    headers?: {
        [key: string]: string;
    } | null;
    /**
     * HTTP method (default: POST)
     */
    method?: string | null;
    /**
     * Optional relative path to append to the publisher base URL
     */
    path?: string | null;
    pre_authorization?: PreAuthorization | null;
    /**
     * Publisher slug (alternative to `publisher_id`)
     */
    publisher?: string | null;
    /**
     * Publisher UUID (required if `publisher` slug not provided)
     */
    publisher_id?: string | null;
    /**
     * Optional idempotency key (UUID) for deduplication
     */
    request_id?: string | null;
};

/**
 * API result response
 */
export type ApiResultResponse = {
    /**
     * Asset symbol (e.g., USDC, USDT)
     */
    asset_symbol: string;
    /**
     * Response body (JSON if available, otherwise raw text)
     */
    body: unknown;
    /**
     * Actual cost charged in configured asset
     */
    cost: string;
    cost_breakdown?: CostBreakdown | null;
    /**
     * Execution time in milliseconds
     */
    execution_time_ms: number;
    /**
     * Payment source used
     */
    payment_source: string;
    /**
     * Size of the publisher response body in bytes (raw, before JSON parsing).
     */
    response_bytes: number;
    /**
     * HTTP status from publisher
     */
    status: number;
};

/**
 * Request to apply a referral code
 */
export type ApplyReferralRequest = {
    referral_code: string;
};

/**
 * Total balance for a single asset across all publishers
 */
export type AssetBalanceTotal = {
    asset: AssetInfo;
    total_available: number;
    total_balance: number;
    total_balance_atomic: number;
    total_reserved: number;
};

/**
 * Minimal asset info for API responses
 */
export type AssetInfo = {
    contract_address?: string | null;
    decimals: number;
    id: string;
    is_native: boolean;
    is_stablecoin: boolean;
    name: string;
    network_id: string;
    network_name: string;
    symbol: string;
};

export type AssignProjectVpcEndpointRequest = {
    label?: string | null;
    vpc_endpoint_id: string;
};

/**
 * Request to assign a role to a member
 */
export type AssignRoleRequest = {
    /**
     * Either role_id or role_name must be provided
     */
    role_id?: string | null;
    /**
     * Name of the role (owner, admin, editor, viewer, or custom role name)
     */
    role_name?: string | null;
};

/**
 * Audit log entry from the database
 */
export type AuditLog = {
    action: string;
    action_category?: string | null;
    actor_id?: string | null;
    actor_type: string;
    created_at: string;
    error_message?: string | null;
    id: string;
    ip_address?: string | null;
    metadata?: unknown;
    organization_id?: string | null;
    request_id?: string | null;
    resource_id?: string | null;
    resource_type: string;
    status: string;
    user_agent?: string | null;
};

/**
 * Response for listing audit logs
 */
export type AuditLogList = {
    data: Array<AuditLog>;
    limit: number;
    offset: number;
    total: number;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type AuditLogListResponse = {
    data: AuditLogList;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type AuditLogResponse = {
    data: AuditLog;
    pagination?: PaginationMeta | null;
};

export type BalanceResponse = {
    balance: number;
};

/**
 * High-level billing health summary.
 */
export type BillingHealth = {
    /**
     * Total failures recorded for the daily aggregation job since process start.
     */
    daily_aggregation_failures_total: number;
    /**
     * True when we have a recent daily aggregation run and no known failures.
     */
    daily_aggregation_ok: boolean;
    /**
     * True when the last daily aggregation was within the expected window (<= 30h old).
     */
    has_recent_daily_run: boolean;
    /**
     * Failure counters per billing job since process start.
     */
    jobs: Array<BillingJobHealth>;
    /**
     * Last time daily_aggregated_usage was written, in UTC (RFC3339).
     */
    last_daily_aggregation_run_utc?: string | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type BillingHealthResponse = {
    data: BillingHealth;
    pagination?: PaginationMeta | null;
};

/**
 * Billing job health for a single background job.
 */
export type BillingJobHealth = {
    failures_total: number;
    job: string;
};

/**
 * Wrapped bonus claim response for OpenAPI
 */
export type BonusClaimDataResponse = {
    data: BonusClaimResponse;
};

/**
 * Response for claiming bonuses
 */
export type BonusClaimResponse = {
    amount_atomic: number;
    amount_usd: string;
    bonus_type: string;
    success: boolean;
};

/**
 * Branch represents a SerenDB timeline (database copy)
 */
export type Branch = {
    archived: boolean;
    created_at: string;
    created_by: string;
    deleted_at?: string | null;
    deleted_by?: string | null;
    expires_at?: string | null;
    id: string;
    init_source?: string | null;
    /**
     * Computed field: true if this branch is the project's default branch.
     * Not stored in DB - computed by comparing branch.id with project.default_branch_id.
     */
    is_default?: boolean;
    last_reset_at?: string | null;
    logical_size_bytes?: number;
    name: string;
    parent_branch_id?: string | null;
    parent_lsn?: string | null;
    parent_timestamp?: string | null;
    physical_size_bytes?: number;
    project_id: string;
    protected: boolean;
    timeline_id: string;
    updated_at: string;
};

/**
 * Branch count response
 */
export type BranchCountResponse = {
    count: number;
};

/**
 * Response after creating a branch
 */
export type BranchCreated = {
    archived: boolean;
    created_at: string;
    id: string;
    init_source?: string | null;
    /**
     * True if this is the project's default branch
     */
    is_default?: boolean;
    logical_size_bytes?: number;
    name: string;
    parent_branch_id?: string | null;
    parent_lsn?: string | null;
    parent_timestamp?: string | null;
    physical_size_bytes?: number;
    project_id: string;
    protected: boolean;
    timeline_id: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type BranchCreatedResponse = {
    data: BranchCreated;
    pagination?: PaginationMeta | null;
};

/**
 * Response wrapper returned when branch creation provisions auxiliary resources
 */
export type BranchCreationResult = {
    branch: BranchCreated;
    /**
     * Error message if endpoint provisioning failed.
     * When present, the branch was created successfully but the endpoint failed.
     * The UI should show a "Retry" or "Add Compute" button.
     */
    endpoint_error?: string | null;
    endpoints?: Array<EndpointCreated> | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type BranchCreationResultResponse = {
    data: BranchCreationResult;
    pagination?: PaginationMeta | null;
};

/**
 * Response for branch detail information
 */
export type BranchDetail = {
    ancestor_lsn?: string | null;
    ancestor_timeline_id?: string | null;
    branch_id: string;
    current_logical_size?: number | null;
    disk_consistent_lsn: string;
    last_record_lsn: string;
    prev_record_lsn?: string | null;
    remote_consistent_lsn?: string | null;
    state: string;
    timeline_id: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type BranchDetailResponse = {
    data: BranchDetail;
    pagination?: PaginationMeta | null;
};

export type BranchEndpointRequest = {
    endpoint_type?: string | null;
    settings?: unknown;
};

/**
 * Branch protection response (API output)
 */
export type BranchProtection = {
    allowed_bypass_roles: Array<string>;
    branch_id: string;
    created_at: string;
    id: string;
    prevent_deletion: boolean;
    prevent_reset: boolean;
    project_id: string;
    require_approval_for_changes: boolean;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type BranchProtectionResponse = {
    data: BranchProtection;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type BranchProtectionsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<BranchProtection>;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type BranchResponse = {
    data: Branch;
    pagination?: PaginationMeta | null;
};

/**
 * Response after restoring a branch
 */
export type BranchRestored = {
    backup_branch: Branch;
    branch: Branch;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type BranchRestoredResponse = {
    data: BranchRestored;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type BranchesResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<Branch>;
    pagination?: PaginationMeta | null;
};

/**
 * Request to call a tool on an MCP publisher
 */
export type CallMcpToolRequest = {
    /**
     * Arguments to pass to the tool (optional)
     */
    arguments?: {
        [key: string]: unknown;
    } | null;
    /**
     * Publisher slug or ID
     */
    publisher?: string | null;
    /**
     * Publisher UUID (alternative to slug)
     */
    publisher_id?: string | null;
    /**
     * Name of the tool to call
     */
    tool_name: string;
};

/**
 * Request to upgrade/downgrade an organization's plan
 */
export type ChangePlanRequest = {
    plan_id: string;
    stripe_payment_method_id?: StripePaymentMethodId | null;
};

/**
 * Compute type - specific compute offering when publisher_category = Compute
 */
export type ComputeType = 'template' | 'workflow' | 'function';

/**
 * Debug view: compute_usage_events entry for an endpoint
 */
export type ComputeUsageEventDebugRecord = {
    event_time: string;
    event_type: string;
};

/**
 * Response for a single, canonical connection string.
 *
 * The backend always prefers SerenDB proxy-based connection strings when
 * proxy configuration is available, and falls back to direct compute
 * connection strings only when the proxy is not configured.
 */
export type ConnectionString = {
    /**
     * Fully resolved PostgreSQL connection string (proxy preferred).
     */
    connection_string: string;
};

/**
 * Query parameters for getting a branch connection string.
 */
export type ConnectionStringQueryParams = {
    /**
     * Return pooled connection (default: false)
     */
    pooled?: boolean | null;
    /**
     * PostgreSQL role/username to use (default: serendb_owner)
     */
    role?: string | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ConnectionStringResponse = {
    data: ConnectionString;
    pagination?: PaginationMeta | null;
};

export type ConnectionsResponse = {
    connections: Array<UserOAuthConnectionResponse>;
};

/**
 * ConsumptionPeriod represents usage metrics for a billing period
 */
export type ConsumptionPeriod = {
    active_time_seconds?: number;
    compute_time_seconds?: number;
    created_at: string;
    data_transfer_bytes?: number;
    id: string;
    organization_id: string;
    period_end: string;
    period_id: string;
    period_start: string;
    project_id: string;
    synthetic_storage_size_bytes?: number;
    updated_at: string;
    written_data_bytes?: number;
};

/**
 * ConsumptionPeriodData for API responses (simplified)
 */
export type ConsumptionPeriodData = {
    active_time_seconds?: number;
    compute_time_seconds?: number;
    data_transfer_bytes?: number;
    period_id: string;
    synthetic_storage_size_bytes?: number;
    written_data_bytes?: number;
};

/**
 * Query parameters for consumption endpoints (reusing the billing usage pattern).
 */
export type ConsumptionQueryParams = {
    /**
     * Optional ISO-8601 end date (YYYY-MM-DD), defaults to today (UTC).
     */
    end_date?: string | null;
    /**
     * Optional ISO-8601 start date (YYYY-MM-DD), defaults to first day of current month.
     */
    start_date?: string | null;
};

/**
 * ConsumptionSummary represents aggregated usage for a period
 */
export type ConsumptionSummary = {
    active_time_seconds?: number;
    compute_time_seconds?: number;
    data_transfer_bytes?: number;
    synthetic_storage_size_bytes?: number;
    written_data_bytes?: number;
};

/**
 * Cost breakdown when a service fee is charged (pre-authorization).
 */
export type CostBreakdown = {
    /**
     * Service fee charged
     */
    service_fee: string;
    /**
     * Cost charged for the target API
     */
    target: string;
    /**
     * Total cost (target + service_fee)
     */
    total: string;
};

/**
 * Cost estimate breakdown
 */
export type CostEstimate = {
    /**
     * Asset symbol (e.g., USDC, USDT)
     */
    asset_symbol: string;
    /**
     * Base cost in asset units (as decimal string)
     */
    base_cost: string;
    /**
     * Estimated rows to be returned
     */
    estimated_rows: number;
    /**
     * Markup multiplier
     */
    markup_multiplier: string;
    /**
     * Minimum charge in asset units
     */
    min_charge: string;
    /**
     * Total cost in asset units (as decimal string)
     */
    total_cost: string;
    /**
     * Total cost in atomic units
     */
    total_cost_atomic: number;
};

/**
 * Request to create a new API key
 */
export type CreateApiKeyRequest = {
    expires_in_days?: number | null;
    name: string;
};

/**
 * Request to create or update branch protection
 */
export type CreateBranchProtectionRequest = {
    allowed_bypass_roles?: Array<string>;
    prevent_deletion?: boolean;
    prevent_reset?: boolean;
    require_approval_for_changes?: boolean;
};

/**
 * Request to create a new branch
 */
export type CreateBranchRequest = {
    /**
     * Whether to automatically create an endpoint for this branch.
     * Defaults to true.
     * Set to false to create a branch without compute (equivalent to --no-compute).
     */
    add_endpoint?: boolean;
    archived?: boolean | null;
    endpoints?: Array<BranchEndpointRequest>;
    /**
     * Optional expiration timestamp for auto-deletion of this branch.
     * Useful for temporary dev/preview branches.
     */
    expires_at?: string | null;
    init_source?: string | null;
    name: string;
    parent_branch_id?: string | null;
    parent_lsn?: string | null;
    parent_timestamp?: string | null;
    protected?: boolean | null;
    /**
     * Create branch with schema only (no data).
     * When true, only the database schema is copied, not the data.
     */
    schema_only?: boolean;
};

/**
 * Request to create a new database
 */
export type CreateDatabaseRequest = {
    name: string;
    owner_name?: string | null;
};

/**
 * Request to create a new endpoint
 */
export type CreateEndpointRequest = {
    autoscaling_max?: number;
    autoscaling_min?: number;
    compute_unit?: string;
    endpoint_type?: EndpointType;
    /**
     * Optional name for the endpoint. If not provided, a name will be auto-generated.
     */
    name?: string;
    pooler_enabled?: boolean;
    pooler_mode?: PoolerMode;
    suspend_timeout_seconds?: number;
};

/**
 * Request to create a fiat deposit for agent prepaid balance
 *
 * Note: The wallet address is provided in the URL path, not in the request body.
 */
export type CreateFiatDepositRequest = {
    /**
     * Amount in the currency's standard unit (e.g., 10.00 for $10 USD)
     */
    amount: number;
    /**
     * ISO 4217 currency code (default: USD)
     */
    currency?: string;
    provider?: FiatPaymentProvider;
    /**
     * Publisher to deposit funds for
     */
    publisher_id: string;
    /**
     * Target asset to credit after conversion (e.g., USDC on Base)
     */
    target_asset_id: string;
};

/**
 * Response after creating a fiat deposit
 */
export type CreateFiatDepositResponse = {
    agent_wallet: WalletAddress;
    /**
     * Amount in the deposit currency
     */
    amount: number;
    /**
     * Amount in target asset that will be credited
     */
    amount_in_asset: number;
    /**
     * Data needed to complete payment on client side (e.g., Stripe client_secret)
     * Only included for providers that need client-side completion
     */
    client_data?: string | null;
    /**
     * ISO 4217 currency code
     */
    currency: string;
    /**
     * Deposit record ID
     */
    id: string;
    /**
     * Provider's payment identifier
     */
    payment_id: string;
    provider: FiatPaymentProvider;
    /**
     * Publisher ID
     */
    publisher_id: string;
    status: FiatDepositStatus;
    target_asset: AssetInfo;
};

/**
 * Request to create/update an OAuth provider (admin only)
 */
export type CreateOAuthProviderRequest = {
    authorization_url: string;
    client_id: string;
    /**
     * Client secret (will be encrypted)
     */
    client_secret: string;
    description?: string | null;
    logo_url?: string | null;
    name: string;
    pkce_required?: boolean;
    revocation_url?: string | null;
    scopes: Array<string>;
    slug: string;
    token_endpoint_auth_method?: string;
    token_url: string;
    userinfo_url?: string | null;
};

/**
 * Request body for creating an organization invite.
 */
export type CreateOrganizationInviteRequest = {
    /**
     * Email address of the invitee.
     */
    email: string;
    /**
     * Optional role for the invitee (defaults to member).
     */
    role?: string | null;
};

export type CreateOrganizationVpcEndpointRequest = {
    endpoint_id: string;
    label?: string | null;
    region: string;
};

/**
 * Request to create a new project
 */
export type CreateProjectRequest = {
    block_public_connections?: boolean | null;
    block_vpc_connections?: boolean | null;
    compute_unit_max?: number | null;
    compute_unit_min?: number | null;
    /**
     * Enable logical replication for this project. Sets wal_level=logical for all compute endpoints.
     * Once enabled, this cannot be disabled.
     */
    enable_logical_replication?: boolean | null;
    hipaa?: boolean | null;
    name: string;
    protected_branches_only?: boolean | null;
    region: string;
};

/**
 * Request to create a promo code (admin)
 */
export type CreatePromoCodeRequest = {
    code: string;
    credit_amount_usd: string;
    /**
     * Days until granted credits expire (None = never)
     */
    credit_expires_days?: number | null;
    description?: string | null;
    /**
     * Max total redemptions (None = unlimited)
     */
    max_redemptions?: number | null;
    /**
     * If true, each org can only redeem once
     */
    one_per_org?: boolean;
    /**
     * Code becomes valid at this time (None = immediately)
     */
    valid_from?: string | null;
    /**
     * Code expires at this time (None = never)
     */
    valid_until?: string | null;
};

/**
 * Request to create a publication
 */
export type CreatePublicationRequest = {
    name: string;
    publish_delete?: boolean;
    publish_insert?: boolean;
    publish_truncate?: boolean;
    publish_update?: boolean;
    /**
     * Tables to include (empty/null means ALL TABLES)
     */
    tables?: Array<string>;
};

/**
 * Request to create a publisher payout.
 */
export type CreatePublisherPayoutRequest = {
    /**
     * Amount to withdraw in atomic units (defaults to max available)
     */
    amount_atomic?: number | null;
    /**
     * Asset to withdraw (must be an asset accepted by the publisher)
     */
    asset_id: string;
    destination_wallet?: WalletAddress | null;
};

/**
 * Request to create a new publisher
 */
export type CreatePublisherRequest = {
    /**
     * Asset IDs the publisher accepts for payment
     */
    accepted_asset_ids?: Array<string> | null;
    /**
     * Whitelist of agent-provided headers allowed to pass through to upstream
     */
    allowed_passthrough_headers?: Array<string>;
    /**
     * Headers for API requests (will be encrypted)
     */
    api_headers?: unknown;
    /**
     * Header name to inject upstream_api_key into (e.g., "Authorization", "X-API-Key")
     */
    api_key_header?: string | null;
    /**
     * Query parameter name to inject upstream_api_key into (e.g., "api_key")
     */
    api_key_query_param?: string | null;
    /**
     * External API URL (required for integration_type = api)
     */
    api_url?: string | null;
    /**
     * Upstream auth mode ("static", "jwt", or "oauth2_cc") (default: static)
     */
    auth_type?: string | null;
    base_price_per_1000_rows?: string | null;
    /**
     * Billing model ("x402_per_request", "prepaid_credits", "x402_passthrough")
     */
    billing_model?: string | null;
    /**
     * SerenDB branch ID (required for database_type = serendb)
     */
    branch_id?: string | null;
    /**
     * Publisher-declared capabilities for task matching
     */
    capabilities?: Array<string>;
    categories?: Array<string>;
    compute_type?: ComputeType | null;
    /**
     * Provider-specific configuration
     * For connection_string auth: { "connection_string": "postgresql://..." }
     */
    database_config?: unknown;
    /**
     * Database name within the SerenDB project (default: serendb)
     */
    database_name?: string | null;
    database_type?: DatabaseType | null;
    description?: string | null;
    /**
     * Publisher contact email for notifications and support
     */
    email?: string | null;
    /**
     * Structured endpoint definitions for LLM discoverability and access control
     */
    endpoints?: Array<EndpointDefinition> | null;
    /**
     * Gateway fee percentage for upstream x402 payments (pass-through).
     */
    gateway_fee_percent?: string | null;
    grace_period_minutes?: number | null;
    hourly_rate?: string | null;
    integration_type?: IntegrationType | null;
    /**
     * JWT access key / issuer claim (plaintext)
     */
    jwt_access_key?: string | null;
    /**
     * JWT signing algorithm ("HS256", "HS384", "HS512") (default: HS256)
     */
    jwt_algorithm?: string | null;
    /**
     * JWT expiration seconds (60-86400, default: 1800)
     */
    jwt_expiration_seconds?: number | null;
    /**
     * JWT secret key (will be encrypted)
     */
    jwt_secret_key?: string | null;
    /**
     * Optional publisher branding URL
     */
    logo_url?: string | null;
    low_balance_threshold?: string | null;
    markup_multiplier?: string | null;
    /**
     * MCP server endpoint URL (required for integration_type = mcp)
     */
    mcp_endpoint?: string | null;
    minimum_balance?: string | null;
    name: string;
    /**
     * OAuth2 client ID for Client Credentials flow
     */
    oauth2_client_id?: string | null;
    /**
     * OAuth2 client secret for Client Credentials flow (will be encrypted)
     */
    oauth2_client_secret?: string | null;
    /**
     * OAuth2 scopes to request during Client Credentials flow
     */
    oauth2_scopes?: Array<string>;
    /**
     * OAuth2 token endpoint URL for Client Credentials flow
     */
    oauth2_token_url?: string | null;
    /**
     * OAuth provider slug for BYOC (Bring Your Own Credentials) authentication.
     * When set along with requires_user_oauth=true, users must connect their own
     * OAuth account before using this publisher.
     */
    oauth_provider_slug?: string | null;
    /**
     * Enable resource ownership tracking (legacy gateway parity)
     */
    ownership_tracking_enabled?: boolean | null;
    price_per_call?: string | null;
    price_per_delete?: string | null;
    /**
     * Price per execution for agent templates or usage-based billing
     */
    price_per_execution?: string | null;
    price_per_get?: string | null;
    price_per_patch?: string | null;
    price_per_post?: string | null;
    price_per_put?: string | null;
    /**
     * SerenDB project ID (required for database_type = serendb)
     */
    project_id?: string | null;
    /**
     * Protected operations configuration - legacy, use endpoints[].is_protected instead
     */
    protected_operations?: unknown;
    publisher_category: PublisherCategory;
    publisher_type?: PublisherType | null;
    /**
     * Content-Type for upstream API requests (default: application/json)
     */
    request_content_type?: string | null;
    /**
     * If true, users must connect via OAuth before using this publisher (BYOC mode).
     * Requires oauth_provider_slug to be set.
     */
    requires_user_oauth?: boolean;
    resource_description?: string | null;
    /**
     * JSONPath to resource ID in response body (for ownership tracking)
     */
    resource_id_response_path?: string | null;
    /**
     * URL pattern with :resourceId placeholder (for ownership tracking)
     */
    resource_id_url_pattern?: string | null;
    resource_name?: string | null;
    slug: string;
    /**
     * TTL for cached exchanged tokens in seconds (60-86400, default: 3600)
     */
    token_cache_ttl_seconds?: number | null;
    /**
     * HTTP method for exchange endpoint (POST or GET, default: POST)
     */
    token_exchange_method?: string | null;
    /**
     * How to send Seren token: header, body, or query (default: header)
     */
    token_exchange_mode?: string | null;
    /**
     * URL to call for exchanging Seren API keys for publisher auth tokens
     */
    token_exchange_url?: string | null;
    /**
     * JSON field in exchange response containing the token (default: access_token)
     */
    token_response_field?: string | null;
    undocumented_endpoint_policy?: UndocumentedEndpointPolicy | null;
    /**
     * Upstream static API key (will be encrypted)
     */
    upstream_api_key?: string | null;
    /**
     * Dot-separated path to upstream cost in response body (for prepaid passthrough billing).
     * Example: "usage.cost"
     */
    upstream_cost_response_path?: string | null;
    /**
     * Non-sensitive headers to send to upstream API (e.g., User-Agent)
     */
    upstream_headers?: unknown;
    /**
     * Usage examples showing how to call the publisher's API
     */
    usage_examples?: Array<UsageExample> | null;
    /**
     * Human-readable use case descriptions
     */
    use_cases?: Array<string>;
    wallet_address: WalletAddress;
    /**
     * Network ID for wallet (CAIP-2 format, e.g., "eip155:8453" for Base)
     */
    wallet_network_id: string;
};

/**
 * Request to create a replication slot
 */
export type CreateReplicationSlotRequest = {
    name: string;
    /**
     * Plugin for logical slots (default: pgoutput)
     */
    plugin?: string;
    /**
     * Slot type: logical or physical (default: logical)
     */
    slot_type?: string;
};

/**
 * Request to create a custom role
 */
export type CreateRoleRequest = {
    description?: string | null;
    name: string;
    permissions: Array<string>;
};

/**
 * Request to create/publish an agent template
 */
export type CreateTemplateRequest = {
    /**
     * Template source code implementing run(input) -> output
     */
    code: string;
    /**
     * Preferred compute backend (e.g., "daytona", "modal"). If not specified, uses default.
     */
    computeBackend?: string | null;
    /**
     * Package dependencies (e.g., ["requests", "openai"])
     */
    dependencies?: Array<string> | null;
    /**
     * Description of what the template does
     */
    description?: string | null;
    /**
     * Programming language (python, typescript, rust)
     */
    language: string;
    llmConfig?: LlmConfig | null;
    /**
     * Display name
     */
    name: string;
    /**
     * Price per invocation (e.g., "0.05" for $0.05)
     */
    price: string;
    /**
     * URL-friendly slug (unique identifier)
     */
    slug: string;
};

/**
 * Response after creating a template
 */
export type CreateTemplateResponse = {
    createdAt: string;
    description?: string | null;
    id: string;
    isVerified: boolean;
    language: TemplateLanguage;
    name: string;
    priceAtomic: number;
    slug: string;
};

/**
 * Request to create a fiat deposit using the authenticated user's virtual wallet.
 *
 * This is the preferred endpoint for fiat users - it automatically uses their
 * platform-generated virtual wallet, so they don't need to manage wallet addresses.
 */
export type CreateUserDepositRequest = {
    /**
     * Amount in the currency's standard unit (e.g., 10.00 for $10 USD)
     */
    amount: number;
    /**
     * ISO 4217 currency code (default: USD)
     */
    currency?: string;
    provider?: FiatPaymentProvider;
    /**
     * Publisher to deposit funds for
     */
    publisher_id: string;
    /**
     * Target asset to credit after conversion
     */
    target_asset_id: string;
};

/**
 * Request to create a webhook
 */
export type CreateWebhookRequest = {
    events: Array<string>;
    name: string;
    project_id?: string | null;
    url: string;
};

/**
 * Summary of an organization's credit balance
 */
export type CreditBalanceSummary = {
    grants: Array<CreditGrantSummary>;
    organization_id: string;
    total_remaining_usd: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type CreditBalanceSummaryResponse = {
    data: CreditBalanceSummary;
    pagination?: PaginationMeta | null;
};

/**
 * A credit grant issued to an organization
 */
export type CreditGrant = {
    amount_usd: string;
    created_at: string;
    description?: string | null;
    expiration_notified_at?: string | null;
    expires_at?: string | null;
    granted_by?: string | null;
    id: string;
    low_balance_notified_at?: string | null;
    organization_id: string;
    promo_code_id?: string | null;
    remaining_usd: string;
    source: string;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type CreditGrantResponse = {
    data: CreditGrant;
    pagination?: PaginationMeta | null;
};

/**
 * Summary of a single credit grant for API responses
 */
export type CreditGrantSummary = {
    amount_usd: string;
    created_at: string;
    description?: string | null;
    expires_at?: string | null;
    id: string;
    remaining_usd: string;
    source: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type CreditGrantsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<CreditGrant>;
    pagination?: PaginationMeta | null;
};

/**
 * Source of a credit grant
 */
export type CreditSource = 'manual' | 'promotional' | 'trial' | 'support' | 'referral';

/**
 * A transaction recording credit usage
 */
export type CreditTransaction = {
    amount_usd: string;
    balance_after: string;
    created_at: string;
    credit_grant_id: string;
    description?: string | null;
    id: string;
    invoice_id?: string | null;
};

/**
 * Credit transaction history response
 */
export type CreditTransactionHistory = {
    organization_id: string;
    transactions: Array<CreditTransactionRecord>;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type CreditTransactionHistoryResponse = {
    data: CreditTransactionHistory;
    pagination?: PaginationMeta | null;
};

/**
 * A credit transaction for API responses
 */
export type CreditTransactionRecord = {
    amount_usd: string;
    balance_after: string;
    created_at: string;
    credit_grant_id: string;
    description?: string | null;
    id: string;
    invoice_id?: string | null;
};

/**
 * A validated currency code.
 *
 * Supports:
 * - ISO 4217 fiat currencies (USD, EUR, GBP, etc.)
 * - Common crypto currencies (USDC, SOL, ETH, etc.)
 *
 * # Examples
 *
 * ```
 * use seren_core::models::CurrencyCode;
 *
 * let usd = CurrencyCode::new("USD").unwrap();
 * let usdc = CurrencyCode::new("USDC").unwrap();
 * assert!(CurrencyCode::new("invalid").is_err());
 * ```
 */
export type CurrencyCode = string;

/**
 * Wrapped daily claim response for OpenAPI
 */
export type DailyClaimDataResponse = {
    data: DailyClaimResponse;
};

/**
 * Wrapped daily eligibility response for OpenAPI
 */
export type DailyClaimEligibilityDataResponse = {
    data: DailyClaimEligibilityResponse;
};

/**
 * Response for daily claim eligibility check
 */
export type DailyClaimEligibilityResponse = {
    can_claim: boolean;
    /**
     * Formatted USD amount that will be granted on a successful daily claim.
     * Optional to avoid breaking older clients.
     */
    claim_amount_usd?: string | null;
    claims_remaining_this_month: number;
    reason?: string | null;
    /**
     * Seconds until the daily claim resets (midnight UTC).
     * Only present when can_claim is false due to already claiming today.
     */
    resets_in_seconds?: number | null;
};

/**
 * Response for claiming daily credits
 */
export type DailyClaimResponse = {
    amount_atomic: number;
    amount_usd: string;
    balance_atomic: number;
    balance_usd: string;
    claims_remaining_this_month: number;
    success: boolean;
};

/**
 * Database within a SerenDB branch
 */
export type Database = {
    branch_id: string;
    created_at: string;
    /**
     * User who created the database. None for databases created via SQL on compute (DDL sync).
     */
    created_by?: string | null;
    deleted_at?: string | null;
    deleted_by?: string | null;
    id: string;
    /**
     * System databases (like postgres) are hidden from users
     */
    is_system: boolean;
    name: string;
    owner_role_id?: string | null;
    updated_at: string;
};

/**
 * Authentication method for database providers
 */
export type DatabaseAuthMethod = 'connection_string';

/**
 * Database configuration for external providers
 *
 * Both Neon and Supabase use connection string authentication.
 */
export type DatabaseConfig = {
    auth_method?: DatabaseAuthMethod;
    /**
     * Encrypted connection string
     * Input: "connection_string" (plaintext)
     * Stored: "connection_string_encrypted" (encrypted)
     */
    connection_string_encrypted?: string | null;
};

/**
 * Response after creating a database
 */
export type DatabaseCreated = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    owner_role_id?: string | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DatabaseCreatedResponse = {
    data: DatabaseCreated;
    pagination?: PaginationMeta | null;
};

/**
 * Supported external database providers
 */
export type DatabaseProvider = 'neon' | 'supabase' | 'planetscale' | 'turso' | 'mongodb';

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DatabaseResponse = {
    data: Database;
    pagination?: PaginationMeta | null;
};

/**
 * Database type - specific database provider when publisher_category = Database
 */
export type DatabaseType = 'serendb' | 'neon' | 'supabase' | 'mongodb';

/**
 * Database with full project and branch context for cross-project listing
 */
export type DatabaseWithContext = {
    /**
     * Branch ID
     */
    branch_id: string;
    /**
     * Human-readable branch name
     */
    branch_name: string;
    created_at: string;
    /**
     * Database ID
     */
    id: string;
    /**
     * Whether this is the project's default branch
     */
    is_default_branch: boolean;
    /**
     * Database name
     */
    name: string;
    /**
     * Database owner role name
     */
    owner_name?: string | null;
    /**
     * Project ID
     */
    project_id: string;
    /**
     * Human-readable project name
     */
    project_name: string;
};

/**
 * Database with owner role name included
 */
export type DatabaseWithOwner = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    owner_name?: string | null;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DatabaseWithOwnerResponse = {
    data: DatabaseWithOwner;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DatabasesResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<Database>;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DatabasesWithContextResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<DatabaseWithContext>;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DatabasesWithOwnerResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<DatabaseWithOwner>;
    pagination?: PaginationMeta | null;
};

export type DeductBalanceRequest = {
    amount: number;
    endpoint_id: string;
    query_hash: string;
    timestamp: number;
    user_id?: string | null;
};

export type DeductBalanceResponse = {
    new_balance: number;
    transaction_id: string;
};

/**
 * Wrapped deposit response for OpenAPI
 */
export type DepositDataResponse = {
    data: DepositResponse;
};

/**
 * Request to deposit funds via Stripe
 */
export type DepositRequest = {
    /**
     * Amount in USD cents (minimum 500 = $5.00)
     */
    amount_cents: number;
};

/**
 * Response for wallet deposit initiation
 */
export type DepositResponse = {
    /**
     * Base deposit amount in atomic units
     */
    amount_atomic: number;
    amount_usd: string;
    /**
     * Tier bonus in atomic units (if applicable)
     */
    bonus_atomic: number;
    bonus_usd: string;
    /**
     * URL to the Stripe hosted checkout page - open this in a browser to complete payment
     */
    checkout_url: string;
    deposit_id: string;
    /**
     * Total to be credited in atomic units
     */
    total_atomic: number;
    total_usd: string;
};

/**
 * Request to discover capabilities of an MCP publisher
 */
export type DiscoverMcpCapabilitiesRequest = {
    /**
     * Publisher slug or ID
     */
    publisher?: string | null;
    /**
     * Publisher UUID (alternative to slug)
     */
    publisher_id?: string | null;
};

/**
 * EIP-712 domain (matches ethereum.rs Eip712Domain)
 */
export type Eip712Domain = {
    chainId: number;
    name: string;
    verifyingContract: string;
    version: string;
};

/**
 * EIP-712 message for TransferWithAuthorization
 */
export type Eip712Message = {
    from: string;
    nonce: string;
    to: string;
    validAfter: string;
    validBefore: string;
    value: string;
};

/**
 * EIP-712 typed data for signing payment authorization
 */
export type Eip712TypedData = {
    domain: Eip712Domain;
    message: Eip712Message;
    primaryType: string;
    types: Eip712Types;
};

/**
 * EIP-712 type definitions
 */
export type Eip712Types = {
    EIP712Domain: Array<TypedParam>;
    TransferWithAuthorization: Array<TypedParam>;
};

/**
 * A validated email address.
 *
 * This type ensures email addresses are validated at construction time.
 * Stored as TEXT in the database via SQLx's transparent encoding.
 *
 * # Examples
 *
 * ```
 * use seren_core::models::Email;
 *
 * let email = Email::new("user@example.com").unwrap();
 * assert!(Email::new("invalid").is_err());
 * ```
 */
export type Email = string;

export type EmailVerified = {
    message: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type EmailVerifiedResponse = {
    data: EmailVerified;
    pagination?: PaginationMeta | null;
};

/**
 * Endpoint represents a compute instance for a branch
 */
export type Endpoint = {
    active_time_seconds?: number;
    autoscaling_max: number;
    autoscaling_min: number;
    branch_id: string;
    compute_unit: string;
    connection_count?: number;
    connection_string?: string | null;
    connection_string_direct?: string | null;
    connection_string_pooled?: string | null;
    created_at: string;
    created_by: string;
    current_state?: string | null;
    /**
     * Type of endpoint: read_write (primary) or read_only (replica)
     */
    endpoint_type: string;
    id: string;
    last_active_at?: string | null;
    name: string;
    pooler_enabled: boolean;
    pooler_mode: string;
    /**
     * Reference to the primary endpoint for read replicas (NULL for read_write endpoints)
     */
    primary_endpoint_id?: string | null;
    proxy_host?: string | null;
    status: string;
    suspend_timeout_seconds: number;
    tenant_id: string;
    timeline_id: string;
    updated_at: string;
};

/**
 * Combined debug response for an endpoint's billing events
 */
export type EndpointBillingEvents = {
    compute_usage_events: Array<ComputeUsageEventDebugRecord>;
    endpoint_id: string;
    organization_id: string;
    usage_events: Array<UsageEventDebugRecord>;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type EndpointBillingEventsResponse = {
    data: EndpointBillingEvents;
    pagination?: PaginationMeta | null;
};

/**
 * Response after creating an endpoint
 */
export type EndpointCreated = {
    branch_id: string;
    compute_unit: string;
    connection_string?: string | null;
    connection_string_direct?: string | null;
    connection_string_pooled?: string | null;
    created_at: string;
    /**
     * Type of endpoint: read_write (primary) or read_only (replica)
     */
    endpoint_type: string;
    id: string;
    internal_http_address?: string | null;
    name: string;
    pg_address?: string | null;
    /**
     * Reference to the primary endpoint for read replicas
     */
    primary_endpoint_id?: string | null;
    status: string;
    warnings?: Array<string> | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type EndpointCreatedResponse = {
    data: EndpointCreated;
    pagination?: PaginationMeta | null;
};

/**
 * A structured endpoint definition for LLM discoverability and access control
 */
export type EndpointDefinition = {
    /**
     * Template for request body with {{query}} placeholder for user input
     * Used by browser extensions and LLMs to construct valid requests
     */
    body_template?: unknown;
    /**
     * Human-readable description of what this endpoint does
     */
    description?: string | null;
    /**
     * Example request body
     */
    example_request?: unknown;
    /**
     * Example response body
     */
    example_response?: unknown;
    /**
     * Whether this is the default endpoint for simple queries
     * When multiple endpoints exist, the default is used for basic operations
     */
    is_default?: boolean;
    /**
     * Whether this endpoint is blocked from agent access
     * Protected endpoints are documented but return 403 if called
     */
    is_protected?: boolean;
    method: HttpMethod;
    /**
     * Path relative to api_url (e.g., "/chat/completions")
     */
    path: string;
    /**
     * Endpoint-specific price override (in asset decimals, e.g., "0.49" for $0.49)
     * If set, takes precedence over method-level pricing (price_per_post, etc.)
     */
    price?: string | null;
    /**
     * Reason for protection (shown in 403 response, e.g., "Data redistribution policy")
     */
    protection_reason?: string | null;
    /**
     * Query parameter definitions
     */
    query_params?: Array<QueryParamDefinition> | null;
    /**
     * Request body schema (JSON Schema or simplified description)
     */
    request_body?: unknown;
    /**
     * Headers required for this endpoint (beyond publisher defaults)
     */
    required_headers?: Array<string> | null;
    /**
     * Response schema (JSON Schema or simplified description)
     */
    response?: unknown;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type EndpointResponse = {
    data: Endpoint;
    pagination?: PaginationMeta | null;
};

/**
 * Endpoint status enum
 */
export type EndpointStatus = 'creating' | 'active' | 'idle' | 'suspended' | 'error' | 'deleting';

/**
 * Status response used by lifecycle endpoints
 */
export type EndpointStatusInfo = {
    compute_status?: string | null;
    id: string;
    k8s_ready: boolean;
    status: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type EndpointStatusInfoResponse = {
    data: EndpointStatusInfo;
    pagination?: PaginationMeta | null;
};

/**
 * Endpoint type enum - distinguishes between primary and replica endpoints
 */
export type EndpointType = 'read_write' | 'read_only';

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type EndpointsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<Endpoint>;
    pagination?: PaginationMeta | null;
};

/**
 * Query estimate request body
 */
export type EstimateRequestBody = {
    /**
     * Optional asset id to estimate pricing for (defaults to publisher primary asset)
     */
    asset_id?: string | null;
    /**
     * Publisher UUID
     */
    publisher_id: string;
    /**
     * SQL query to estimate
     */
    query: string;
};

/**
 * Query estimate response
 */
export type EstimateResponse = {
    /**
     * Asset symbol (e.g., USDC, USDT)
     */
    asset_symbol: string;
    /**
     * Estimated cost in configured asset
     */
    estimated_cost: string;
    /**
     * Estimated cost in atomic units
     */
    estimated_cost_atomic: number;
    /**
     * Estimated rows to be returned
     */
    estimated_rows: number;
    /**
     * Publisher name
     */
    publisher_name: string;
    /**
     * Publisher slug
     */
    publisher_slug: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type FiatDepositDataResponse = {
    data: FiatDepositResponse;
    pagination?: PaginationMeta | null;
};

/**
 * Response for deposit status/history (without sensitive client data)
 */
export type FiatDepositResponse = {
    agent_wallet: WalletAddress;
    /**
     * Amount in the deposit currency
     */
    amount: number;
    /**
     * Amount in target asset credited/to be credited
     */
    amount_in_asset: number;
    /**
     * Provider's charge ID (if payment completed)
     */
    charge_id?: string | null;
    completed_at?: string | null;
    created_at: string;
    /**
     * ISO 4217 currency code
     */
    currency: string;
    failure_code?: string | null;
    failure_message?: string | null;
    id: string;
    /**
     * Provider's payment identifier
     */
    payment_id: string;
    provider: FiatPaymentProvider;
    publisher_id: string;
    status: FiatDepositStatus;
    target_asset: AssetInfo;
};

/**
 * Status of fiat deposit for agent prepaid balance
 */
export type FiatDepositStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'refunded' | 'expired' | 'cancelled';

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type FiatDepositsDataResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<FiatDepositResponse>;
    pagination?: PaginationMeta | null;
};

/**
 * Payment provider for fiat deposits
 */
export type FiatPaymentProvider = 'stripe' | 'paypal' | 'coinbase' | 'wire';

export type ForgotPasswordRequest = {
    email: Email;
};

export type GenerateInvoicesRequest = {
    month: number;
    year: number;
};

/**
 * Request to grant credits to an organization (admin)
 */
export type GrantCreditsRequest = {
    amount_usd: string;
    description?: string | null;
    /**
     * Days until expiration (None = never expires)
     */
    expires_in_days?: number | null;
    organization_id: string;
    source: CreditSource;
};

/**
 * HTTP method for endpoint definitions
 */
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

/**
 * Integration type - specific integration when publisher_category = Integration
 */
export type IntegrationType = 'api' | 'mcp';

/**
 * Internal authorization request from SerenDB proxy
 */
export type InternalAuthorizeRequest = {
    /**
     * Agent wallet address.
     *
     * - For on-chain credentials: this must be the agent's real wallet address.
     * - For account-based credentials (JWT/API key): this can be any placeholder;
     * SerenCore derives the canonical wallet from the validated identity.
     */
    agent_wallet?: string | null;
    /**
     * Publisher slug to access
     */
    publisher_slug: string;
    /**
     * Authorization proof.
     *
     * - For account-based (fiat/prepaid): SerenCore user JWT or API key (`seren_...`)
     * - For real on-chain wallets: EIP-191 personal_sign of
     * `agent:<publisher_slug>:<agent_wallet>`
     * - For streaming payments (EIP-3009): JSON payload string
     */
    signature?: string | null;
};

/**
 * Internal authorization response
 */
export type InternalAuthorizeResponse = {
    /**
     * Canonical agent wallet address for the authorized session.
     *
     * - For virtual wallets: derived from the provided SerenCore credential (JWT/API key).
     * - For on-chain wallets: the wallet address provided by the agent.
     */
    agent_wallet?: string | null;
    asset?: ProxyAssetInfo | null;
    /**
     * Whether authorization succeeded
     */
    authorized: boolean;
    balance?: ProxyBalanceInfo | null;
    /**
     * Error message if failed
     */
    error?: string | null;
    pricing?: ProxyPricingInfo | null;
    publisher?: ProxyPublisherInfo | null;
    /**
     * Session expiration (Unix timestamp)
     */
    session_expires_at?: number | null;
    /**
     * Session token for subsequent requests
     */
    session_token?: string | null;
};

/**
 * Internal charge request from proxy
 */
export type InternalChargeRequest = {
    /**
     * Actual rows returned
     */
    actual_rows?: number | null;
    /**
     * Agent wallet
     */
    agent_wallet: string;
    /**
     * Estimated rows
     */
    estimated_rows: number;
    /**
     * Execution time in ms
     */
    execution_time_ms?: number | null;
    /**
     * Publisher ID
     */
    publisher_id: string;
    /**
     * Query hash for deduplication
     */
    query_hash: string;
    /**
     * Query type (SELECT, INSERT, etc.)
     */
    query_type: string;
    /**
     * Unique request ID for idempotency (UUID v5 for deterministic deduplication)
     */
    request_id: string;
    /**
     * Session token from authorization
     */
    session_token: string;
};

/**
 * Internal charge response
 */
export type InternalChargeResponse = {
    /**
     * Amount charged in atomic units
     */
    amount_charged_atomic: number;
    /**
     * Error message if failed
     */
    error?: string | null;
    /**
     * New balance after charge
     */
    new_balance_atomic: number;
    /**
     * Whether charge succeeded
     */
    success: boolean;
    /**
     * Transaction ID for audit
     */
    transaction_id?: string | null;
};

/**
 * Internal release request from proxy
 */
export type InternalReleaseRequest = {
    /**
     * Agent wallet
     */
    agent_wallet: string;
    /**
     * Publisher ID
     */
    publisher_id: string;
    /**
     * Unique request ID for idempotency (UUID v5 for deterministic deduplication)
     */
    request_id: string;
    /**
     * Session token from authorization
     */
    session_token: string;
};

/**
 * Internal release response
 */
export type InternalReleaseResponse = {
    /**
     * Available balance (balance - reserved)
     */
    available_atomic: number;
    /**
     * Balance in atomic units
     */
    balance_atomic: number;
    /**
     * Error message if failed
     */
    error?: string | null;
    /**
     * Amount released in atomic units
     */
    released_amount_atomic: number;
    /**
     * Reserved balance in atomic units
     */
    reserved_atomic: number;
    /**
     * Whether release succeeded
     */
    success: boolean;
};

/**
 * Internal reserve request from proxy
 */
export type InternalReserveRequest = {
    /**
     * Agent wallet
     */
    agent_wallet: string;
    /**
     * Estimated rows
     */
    estimated_rows: number;
    /**
     * Publisher ID
     */
    publisher_id: string;
    /**
     * Query hash for deduplication
     */
    query_hash: string;
    /**
     * Unique request ID for idempotency (UUID v5 for deterministic deduplication)
     */
    request_id: string;
    /**
     * Session token from authorization
     */
    session_token: string;
};

/**
 * Internal reserve response
 */
export type InternalReserveResponse = {
    /**
     * Available balance (balance - reserved)
     */
    available_atomic: number;
    /**
     * Balance in atomic units
     */
    balance_atomic: number;
    /**
     * Error message if failed
     */
    error?: string | null;
    /**
     * Amount reserved in atomic units
     */
    reserved_amount_atomic: number;
    /**
     * Reserved balance in atomic units
     */
    reserved_atomic: number;
    /**
     * Whether reserve succeeded
     */
    success: boolean;
};

/**
 * Cost breakdown for template invocation response
 */
export type InvocationCostBreakdown = {
    computeCost: string;
    llmCost: string;
    llmKeyUsed: string;
    publisherFee: string;
    total: string;
};

/**
 * Invoice response with line items
 */
export type Invoice = {
    id: string;
    invoice_number: string;
    line_items: Array<InvoiceLineItem>;
    organization_id: string;
    period_end: string;
    period_start: string;
    status: string;
    subtotal_usd: number;
    tax_usd: number;
    total_usd: number;
};

/**
 * Invoice line item response
 */
export type InvoiceLineItem = {
    amount_usd: number;
    description: string;
    line_type: string;
    quantity: number;
    unit_price: number;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type InvoiceResponse = {
    data: Invoice;
    pagination?: PaginationMeta | null;
};

/**
 * Response for invoice generation
 */
export type InvoicesGenerated = {
    count: number;
    invoice_ids: Array<string>;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type InvoicesGeneratedResponse = {
    data: InvoicesGenerated;
    pagination?: PaginationMeta | null;
};

/**
 * Response wrapper for template invocation
 */
export type InvokeDataResponse = {
    data: InvokeTemplateResponse;
};

/**
 * Request to invoke an agent template
 */
export type InvokeTemplateRequest = {
    /**
     * Input data to pass to the template
     */
    input: unknown;
};

/**
 * Response from invoking a template
 */
export type InvokeTemplateResponse = {
    cost: InvocationCostBreakdown;
    /**
     * Execution time in milliseconds
     */
    executionTimeMs: number;
    /**
     * Invocation ID for tracking
     */
    invocationId: string;
    /**
     * Output from template execution
     */
    result: unknown;
};

/**
 * IP allow list entry for project-level access control
 */
export type IpAllowList = {
    created_at: string;
    created_by: string;
    description?: string | null;
    id: string;
    /**
     * IP address or CIDR range (stored as PostgreSQL CIDR type)
     */
    ip_address: string;
    project_id: string;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type IpAllowListResponse = {
    data: IpAllowList;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type IpAllowListsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<IpAllowList>;
    pagination?: PaginationMeta | null;
};

/**
 * Limits response for API (simplified)
 */
export type LimitsResponse = {
    branches?: number;
    compute_hours?: number;
    data_transfer_gb?: number;
    logical_size_bytes?: number;
    projects?: number;
    storage_gb?: number;
};

/**
 * Query params for listing fiat deposits
 */
export type ListFiatDepositsParams = {
    /**
     * Maximum number of results (default: 50)
     */
    limit?: number | null;
    /**
     * Offset for pagination
     */
    offset?: number | null;
    provider?: FiatPaymentProvider | null;
    /**
     * Filter by publisher
     */
    publisher_id?: string | null;
    status?: FiatDepositStatus | null;
};

/**
 * Request to list resources on an MCP publisher
 */
export type ListMcpResourcesRequest = {
    /**
     * Publisher slug or ID
     */
    publisher?: string | null;
    /**
     * Publisher UUID (alternative to slug)
     */
    publisher_id?: string | null;
};

/**
 * Request to list tools on an MCP publisher
 */
export type ListMcpToolsRequest = {
    /**
     * Publisher slug or ID
     */
    publisher?: string | null;
    /**
     * Publisher UUID (alternative to slug)
     */
    publisher_id?: string | null;
};

/**
 * Query params for listing publisher payouts.
 */
export type ListPublisherPayoutsParams = {
    /**
     * Maximum number of results (default: 50)
     */
    limit?: number | null;
    /**
     * Offset for pagination
     */
    offset?: number | null;
};

/**
 * Query parameters for listing publishers
 */
export type ListPublishersParams = {
    /**
     * Filter by verification status
     */
    is_verified?: boolean | null;
    /**
     * Maximum number of results (default: 50, max: 100)
     */
    limit?: number;
    /**
     * Offset for pagination
     */
    offset?: number;
    /**
     * Search by name or slug
     */
    search?: string | null;
};

/**
 * LLM configuration for templates
 */
export type LlmConfig = {
    /**
     * API key (optional, will be encrypted)
     */
    apiKey?: string | null;
    /**
     * Model name (e.g., "gpt-4o", "claude-3-opus")
     */
    model: string;
    /**
     * LLM provider (e.g., "openai", "anthropic")
     */
    provider: string;
};

/**
 * Project logical replication settings
 */
export type LogicalReplicationSettings = {
    enabled: boolean;
    project_id: string;
    publications_count: number;
    slots_count: number;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type LogicalReplicationSettingsResponse = {
    data: LogicalReplicationSettings;
    pagination?: PaginationMeta | null;
};

export type LoginResult = {
    access_token: string;
    /**
     * The user's default organization ID for API calls requiring an organization context.
     * This is typically the first organization the user joined (their personal org).
     */
    default_organization_id: string;
    expires_in: number;
    refresh_token: string;
    user: UserInfo;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type LoginResultResponse = {
    data: LoginResult;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type LogoUploadDataResponse = {
    data: LogoUploadResponse;
    pagination?: PaginationMeta | null;
};

/**
 * Logo upload request body
 */
export type LogoUploadRequest = {
    /**
     * Content type of the image (image/png, image/jpeg, image/webp, image/svg+xml)
     */
    content_type: string;
    /**
     * Base64 encoded image data
     */
    logo: string;
};

/**
 * Logo upload response
 */
export type LogoUploadResponse = {
    /**
     * URL to access the uploaded logo
     */
    logo_url: string;
    /**
     * Message indicating success
     */
    message: string;
};

/**
 * Response for LSN by timestamp query
 */
export type LsnByTimestamp = {
    lsn: string;
};

/**
 * Query parameters for getting LSN by timestamp.
 */
export type LsnByTimestampQuery = {
    /**
     * ISO 8601 timestamp (e.g., 2024-05-06T10:00:00.000Z)
     */
    timestamp: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type LsnByTimestampResponse = {
    data: LsnByTimestamp;
    pagination?: PaginationMeta | null;
};

/**
 * Discovered capabilities of an MCP server
 */
export type McpCapabilities = {
    prompts?: Array<McpPromptInfo> | null;
    resources?: Array<McpResourceInfo> | null;
    server_name?: string | null;
    server_version?: string | null;
    tools?: Array<McpToolInfo> | null;
};

/**
 * Response containing MCP capabilities
 */
export type McpCapabilitiesResponse = {
    capabilities: McpCapabilities;
    execution_time_ms: number;
};

/**
 * Argument for an MCP prompt
 */
export type McpPromptArgument = {
    description?: string | null;
    name: string;
    required?: boolean | null;
};

/**
 * Information about an MCP prompt
 */
export type McpPromptInfo = {
    arguments?: Array<McpPromptArgument> | null;
    description?: string | null;
    name: string;
};

/**
 * Content of an MCP resource
 */
export type McpResourceContent = {
    blob?: string | null;
    mime_type?: string | null;
    text?: string | null;
    uri: string;
};

/**
 * Information about an MCP resource
 */
export type McpResourceInfo = {
    description?: string | null;
    mime_type?: string | null;
    name: string;
    uri: string;
};

/**
 * Response from reading an MCP resource
 */
export type McpResourceReadResponse = {
    contents: Array<McpResourceContent>;
    execution_time_ms: number;
    response_bytes: number;
};

/**
 * Response containing MCP resources
 */
export type McpResourcesResponse = {
    execution_time_ms: number;
    resources: Array<McpResourceInfo>;
};

/**
 * Response from an MCP tool call
 */
export type McpToolCallResponse = {
    execution_time_ms: number;
    is_error: boolean;
    response_bytes: number;
    result: unknown;
};

/**
 * Information about an MCP tool
 */
export type McpToolInfo = {
    description?: string | null;
    input_schema?: unknown;
    name: string;
};

/**
 * Response containing MCP tools
 */
export type McpToolsResponse = {
    execution_time_ms: number;
    tools: Array<McpToolInfo>;
};

/**
 * A validated network identifier.
 *
 * Supports common blockchain networks. Stored as TEXT in database.
 *
 * # Known Networks
 * - `evm:1` - Ethereum Mainnet
 * - `evm:8453` - Base
 * - `evm:137` - Polygon
 * - `evm:42161` - Arbitrum One
 * - `evm:10` - Optimism
 * - `solana:mainnet` - Solana Mainnet
 * - `solana:devnet` - Solana Devnet
 *
 * # Examples
 *
 * ```
 * use seren_core::models::NetworkId;
 *
 * let eth = NetworkId::new("evm:1").unwrap();
 * assert!(eth.is_evm());
 *
 * let sol = NetworkId::new("solana:mainnet").unwrap();
 * assert!(sol.is_solana());
 * ```
 */
export type NetworkId = string;

/**
 * DataResponse wrapper for OpenAPI schema
 */
export type OAuthProviderDataResponse = {
    data: OAuthProviderResponse;
};

/**
 * Response type for OAuth provider (excludes sensitive fields like client_secret)
 */
export type OAuthProviderResponse = {
    authorization_url: string;
    client_id: string;
    created_at: string;
    description?: string | null;
    id: string;
    is_active: boolean;
    logo_url?: string | null;
    name: string;
    organization_id?: string | null;
    pkce_required: boolean;
    revocation_url?: string | null;
    scopes: Array<string>;
    slug: string;
    token_endpoint_auth_method: string;
    token_url: string;
    updated_at: string;
    userinfo_url?: string | null;
};

/**
 * DataResponse wrapper for list of providers
 */
export type OAuthProvidersDataResponse = {
    data: Array<OAuthProviderResponse>;
};

/**
 * Offset-based pagination metadata
 *
 * Used for APIs that use limit/offset pagination instead of page/per_page.
 * Standard fields following REST API conventions.
 */
export type OffsetPaginationMeta = {
    /**
     * Number of items in this response
     */
    count: number;
    /**
     * Whether more items exist beyond this page
     */
    has_more: boolean;
    /**
     * Maximum items requested
     */
    limit: number;
    /**
     * Starting offset
     */
    offset: number;
    /**
     * Total number of items across all pages
     */
    total: number;
};

/**
 * Request body for on-chain deposit
 */
export type OnchainDepositRequest = {
    /**
     * Amount to deposit in the configured asset (decimal string, e.g., "10.50")
     */
    amount: string;
    /**
     * Optional asset id to deposit (defaults to publisher primary asset)
     */
    asset_id?: string | null;
    /**
     * Publisher to deposit funds for
     */
    publisher_id: string;
};

/**
 * Response after successful on-chain deposit
 */
export type OnchainDepositResponse = {
    agent_wallet: WalletAddress;
    /**
     * Asset symbol (e.g., USDC, USDT)
     */
    asset_symbol: string;
    /**
     * New balance (configured asset)
     */
    balance_amount: string;
    /**
     * Amount deposited (configured asset)
     */
    deposited_amount: string;
    /**
     * Deposit successful message
     */
    message: string;
    /**
     * Publisher ID
     */
    publisher_id: string;
    /**
     * On-chain transaction hash
     */
    tx_hash?: string | null;
};

/**
 * Operation represents an async operation
 */
export type Operation = {
    completed_at?: string | null;
    created_at: string;
    created_by: string;
    error_message?: string | null;
    id: string;
    metadata: {
        [key: string]: unknown;
    } | null;
    operation_type: string;
    progress: number;
    resource_id: string;
    resource_type: string;
    started_at?: string | null;
    status: string;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OperationResponse = {
    data: Operation;
    pagination?: PaginationMeta | null;
};

/**
 * Operation status
 */
export type OperationStatus = 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OperationsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<Operation>;
    pagination?: PaginationMeta | null;
};

export type Organization = {
    created_at: string;
    created_by: string;
    deleted_at?: string | null;
    id: string;
    is_personal: boolean;
    name: string;
    slug: Slug;
    /**
     * Stripe Customer ID for this organization (if billing is enabled).
     */
    stripe_customer_id?: string | null;
    updated_at: string;
};

/**
 * OrganizationConsumption wraps organization-wide consumption
 */
export type OrganizationConsumption = {
    current_month: ConsumptionSummary;
    from: string;
    organization_id: string;
    periods: Array<ConsumptionPeriodData>;
    to: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OrganizationConsumptionResponse = {
    data: OrganizationConsumption;
    pagination?: PaginationMeta | null;
};

/**
 * Response type for organization invites (token is not exposed over the API).
 */
export type OrganizationInvite = {
    accepted_at?: string | null;
    created_at: string;
    email: string;
    expires_at: string;
    id: string;
    invited_by: string;
    organization_id: string;
    revoked_at?: string | null;
    role: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OrganizationInviteResponse = {
    data: OrganizationInvite;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OrganizationInvitesResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<OrganizationInvite>;
    pagination?: PaginationMeta | null;
};

/**
 * Limits represents resource quotas for an organization
 */
export type OrganizationLimits = {
    branches?: number;
    compute_hours?: number;
    created_at: string;
    data_transfer_gb?: number;
    id: string;
    logical_size_bytes?: number;
    organization_id: string;
    projects?: number;
    storage_gb?: number;
    updated_at: string;
};

/**
 * Organization member with denormalized user fields for API responses.
 */
export type OrganizationMemberWithUser = {
    created_at: string;
    email: Email;
    id: string;
    name?: string | null;
    organization_id: string;
    role: string;
    user_id: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OrganizationMembersResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<OrganizationMemberWithUser>;
    pagination?: PaginationMeta | null;
};

/**
 * OrganizationPlan tracks which plan an organization is currently on
 */
export type OrganizationPlan = {
    cancellation_reason?: string | null;
    cancelled_at?: string | null;
    cancelled_by?: string | null;
    created_at: string;
    ends_at?: string | null;
    id: string;
    is_trial: boolean;
    organization_id: string;
    plan_id: string;
    started_at: string;
    stripe_subscription_id?: string | null;
    trial_ends_at?: string | null;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OrganizationPlanResponse = {
    data: OrganizationPlanWithDetails;
    pagination?: PaginationMeta | null;
};

/**
 * Response type that includes both the plan and organization_plan details
 */
export type OrganizationPlanWithDetails = {
    organization_plan: OrganizationPlan;
    plan: Plan;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OrganizationResponse = {
    data: Organization;
    pagination?: PaginationMeta | null;
};

export type OrganizationVpcEndpoint = {
    created_at: string;
    endpoint_id: string;
    id: string;
    label?: string | null;
    organization_id: string;
    region: string;
    state: string;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OrganizationVpcEndpointResponse = {
    data: OrganizationVpcEndpoint;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type OrganizationsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<Organization>;
    pagination?: PaginationMeta | null;
};

/**
 * Paginated response wrapper.
 *
 * Wraps a list of items with pagination metadata.
 */
export type PaginatedBranchResponse = {
    /**
     * The items in this page
     */
    data: Array<Branch>;
    pagination: PaginationMeta;
};

/**
 * Paginated response wrapper.
 *
 * Wraps a list of items with pagination metadata.
 */
export type PaginatedEndpointResponse = {
    /**
     * The items in this page
     */
    data: Array<Endpoint>;
    pagination: PaginationMeta;
};

/**
 * Paginated response wrapper.
 *
 * Wraps a list of items with pagination metadata.
 */
export type PaginatedOperationResponse = {
    /**
     * The items in this page
     */
    data: Array<Operation>;
    pagination: PaginationMeta;
};

/**
 * Paginated response wrapper.
 *
 * Wraps a list of items with pagination metadata.
 */
export type PaginatedProjectResponse = {
    /**
     * The items in this page
     */
    data: Array<Project>;
    pagination: PaginationMeta;
};

/**
 * Response wrapper with offset-based pagination
 *
 * Use this for list endpoints that use limit/offset pagination.
 */
export type PaginatedPublishersResponse = {
    /**
     * The response data
     */
    data: Array<PublisherResponse>;
    pagination: OffsetPaginationMeta;
};

/**
 * Pagination metadata included in responses.
 */
export type PaginationMeta = {
    /**
     * Number of items in this response
     */
    count: number;
    /**
     * Whether there are more items after this page
     */
    has_more: boolean;
    /**
     * Maximum items per page
     */
    limit: number;
    /**
     * Offset from start
     */
    offset: number;
    /**
     * Total number of items across all pages
     */
    total: number;
};

/**
 * Parameter type for query/path parameters
 */
export type ParamType = 'string' | 'integer' | 'boolean' | 'number' | 'array';

export type PasswordReset = {
    message: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PasswordResetResponse = {
    data: PasswordReset;
    pagination?: PaginationMeta | null;
};

export type PasswordResetSent = {
    message: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PasswordResetSentResponse = {
    data: PasswordResetSent;
    pagination?: PaginationMeta | null;
};

/**
 * Payment history response
 */
export type PaymentHistory = {
    payments: Array<PaymentRecord>;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PaymentHistoryResponse = {
    data: PaymentHistory;
    pagination?: PaginationMeta | null;
};

/**
 * Response for creating a payment intent
 */
export type PaymentIntentCreated = {
    amount_usd: number;
    client_secret: string;
    currency: CurrencyCode;
    payment_intent_id: StripePaymentIntentId;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PaymentIntentCreatedResponse = {
    data: PaymentIntentCreated;
    pagination?: PaginationMeta | null;
};

/**
 * Payment method details
 */
export type PaymentMethod = {
    bank_last4?: string | null;
    card_brand?: string | null;
    card_exp_month?: number | null;
    card_exp_year?: number | null;
    card_last4?: string | null;
    id: string;
    is_default: boolean;
    type_: string;
};

/**
 * Response for adding a payment method
 */
export type PaymentMethodAdded = {
    id: string;
    message: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PaymentMethodAddedResponse = {
    data: PaymentMethodAdded;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PaymentMethodsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<PaymentMethod>;
    pagination?: PaginationMeta | null;
};

/**
 * Individual payment record
 */
export type PaymentRecord = {
    amount_usd: number;
    attempted_at: string;
    currency: CurrencyCode;
    failed_at?: string | null;
    failure_code?: string | null;
    failure_message?: string | null;
    id: string;
    status: string;
    stripe_charge_id?: StripeChargeId | null;
    stripe_payment_intent_id: StripePaymentIntentId;
    succeeded_at?: string | null;
};

/**
 * Internal payment request tracking (extends with Seren-specific fields)
 */
export type PaymentRequestInfo = {
    eip712TypedData?: Eip712TypedData | null;
    estimate?: CostEstimate | null;
    /**
     * Expiration timestamp (Unix seconds)
     */
    expires: number;
    /**
     * Payment request ID for correlation
     */
    payment_request_id: string;
    /**
     * Publisher ID
     */
    publisher_id: string;
};

/**
 * x402 V2 402 Payment Required Response
 *
 * The official V2 format with top-level resource info and extensions support.
 */
export type PaymentRequiredResponse = {
    /**
     * List of acceptable payment methods
     */
    accepts: Array<PaymentRequirements>;
    /**
     * Error message explaining why payment is required
     */
    error?: string | null;
    /**
     * Optional extensions (V2 feature for protocol extensibility)
     */
    extensions?: unknown;
    resource: ResourceInfo;
    /**
     * x402 protocol version (2 for V2)
     */
    x402Version: number;
};

/**
 * 402 Payment Required response body (x402 v2) with Seren-specific extensions.
 */
export type PaymentRequiredResponseWithInfo = PaymentRequiredResponse & {
    seren?: PaymentRequestInfo | null;
};

/**
 * x402 V2 Payment Requirements
 *
 * Follows the official x402 V2 specification.
 * See: https://github.com/coinbase/x402/blob/main/typescript/packages/core/src/types/payments.ts
 */
export type PaymentRequirements = {
    /**
     * Amount in atomic units (token decimals)
     */
    amount: string;
    /**
     * Payment asset address (token contract)
     */
    asset: string;
    /**
     * Extra information about the payment (scheme-specific)
     *
     * For EVM/exact scheme, this typically contains:
     * - `name`: Asset name (e.g., "USD Coin")
     * - `version`: Asset version
     * - `eip712TypedData`: EIP-712 typed data for signing (EIP-3009)
     * - `paymentRequestId`: Correlation ID
     * - `expires`: Expiration timestamp
     * - `estimate`: Cost breakdown (optional)
     * - `settlementMethod`: "eip3009" or "transfer"
     */
    extra: unknown;
    /**
     * Maximum time in seconds for the resource server to respond
     */
    maxTimeoutSeconds: number;
    /**
     * Network for payment in CAIP-2 format (e.g., "eip155:8453" for Base mainnet)
     */
    network: string;
    /**
     * Address to pay value to (publisher or gateway wallet)
     */
    payTo: string;
    /**
     * Payment scheme (e.g., "exact")
     */
    scheme: string;
};

/**
 * x402 V1 Payment Requirements.
 *
 * V1 embeds resource information directly inside each requirement.
 */
export type PaymentRequirementsV1 = {
    /**
     * Payment asset address (token contract)
     */
    asset: string;
    /**
     * Human-readable description of the resource
     */
    description: string;
    /**
     * Scheme-specific additional information
     */
    extra?: unknown;
    /**
     * Maximum amount in atomic units (token decimals)
     */
    maxAmountRequired: string;
    /**
     * Maximum time in seconds for the resource server to respond
     */
    maxTimeoutSeconds: number;
    /**
     * MIME type of the resource response
     */
    mimeType?: string | null;
    /**
     * Network for payment (e.g., "base", "base-sepolia")
     */
    network: string;
    /**
     * Optional JSON schema describing the response format
     */
    outputSchema?: unknown;
    /**
     * Payment recipient address (gateway or publisher wallet)
     */
    payTo: string;
    /**
     * URL of the resource being paid for
     */
    resource: string;
    /**
     * Payment scheme (e.g., "exact")
     */
    scheme: string;
};

/**
 * Payment source for transactions
 */
export type PaymentSource = 'onchain' | 'prepaid_balance' | 'credits';

/**
 * Status of a publisher payout request.
 */
export type PayoutStatus = 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled';

/**
 * Permission definition
 */
export type Permission = {
    action: string;
    created_at: string;
    description?: string | null;
    id: string;
    name: string;
    resource_type: string;
};

/**
 * Plan represents a subscription tier (Free, Launch, Scale)
 */
export type Plan = {
    audit_logs_enabled: boolean;
    branch_price_per_hour?: string | null;
    compute_hours_quota?: number | null;
    compute_price_per_cu_hour?: string | null;
    created_at: string;
    data_transfer_gb_included?: number | null;
    data_transfer_price_per_gb?: string | null;
    description?: string | null;
    display_name: string;
    id: string;
    ip_allowlist_enabled: boolean;
    is_active: boolean;
    max_branches_per_project: number;
    max_compute_units: number;
    max_databases_per_branch?: number | null;
    max_endpoints_per_branch?: number | null;
    max_projects?: number | null;
    monitoring_enabled: boolean;
    monitoring_retention_days?: number | null;
    name: string;
    pitr_price_per_gb_month?: string | null;
    pitr_retention_hours?: number | null;
    price_monthly: string;
    scale_to_zero_delay_seconds?: number | null;
    sla_uptime_percent?: string | null;
    sort_order: number;
    sso_enabled: boolean;
    storage_gb_quota?: string | null;
    storage_price_per_gb_month?: string | null;
    /**
     * Stripe Price ID used for recurring subscriptions on this plan (for paid tiers).
     */
    stripe_price_id?: string | null;
    support_level: string;
    updated_at: string;
    vpc_enabled: boolean;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PlanResponse = {
    data: Plan;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PlansResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<Plan>;
    pagination?: PaginationMeta | null;
};

/**
 * Point in time specification (timestamp or LSN)
 */
export type PointInTime = {
    timestamp: string;
} | {
    lsn: string;
};

/**
 * Pooler mode enum
 */
export type PoolerMode = 'transaction' | 'session';

/**
 * Bounded pre-authorization used for automated executions (e.g., scheduled jobs).
 */
export type PreAuthorization = {
    /**
     * Agent wallet address (real wallet for x402, virtual wallet for prepaid).
     */
    agent_wallet: string;
    /**
     * Optional API key id hint (prepaid only) to avoid checking all keys.
     */
    api_key_id?: string | null;
    /**
     * Optional asset to bind the authorization to (prepaid: NULL = any stablecoin).
     */
    asset_id?: string | null;
    auth_type: PreAuthorizationType;
    /**
     * Job ID this pre-authorization applies to.
     */
    job_id: string;
    /**
     * Maximum total charge per execution (atomic units, includes service fee).
     */
    max_per_execution_atomic: number;
    /**
     * Maximum total budget across all executions (atomic units, includes service fee).
     */
    max_total_atomic: number;
    /**
     * Replay-protection nonce (opaque string for prepaid, bytes32 hex for x402).
     */
    nonce: string;
    /**
     * Target publisher this pre-authorization applies to.
     *
     * Must match the `publisher_id` in the surrounding `/agent/api` request.
     */
    publisher_id: string;
    /**
     * Service fee amount charged per execution (atomic units).
     */
    service_fee_per_execution_atomic?: number;
    /**
     * Publisher that receives the service fee (defaults to `publisher_id`).
     */
    service_fee_recipient_id?: string | null;
    /**
     * Signature: EIP-712 for x402, HMAC-SHA256 hex for prepaid.
     */
    signature: string;
    /**
     * User ID (required for prepaid, omitted for x402).
     */
    user_id?: string | null;
    /**
     * Validity window start (Unix seconds).
     */
    valid_after: number;
    /**
     * Validity window end (Unix seconds).
     */
    valid_before: number;
};

/**
 * Pre-authorization signature allowing a service (e.g., SerenCron) to spend on behalf
 * of an agent without storing the agent's credentials.
 */
export type PreAuthorizationType = 'x402' | 'prepaid';

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PricingConfigDataResponse = {
    data: PricingConfigResponse;
    pagination?: PaginationMeta | null;
};

/**
 * Pricing config response
 */
export type PricingConfigResponse = {
    /**
     * Asset this pricing applies to
     */
    asset_id: string;
    /**
     * Asset symbol for display
     */
    asset_symbol?: string | null;
    base_price_per_1000_rows: string;
    grace_period_minutes?: number | null;
    hourly_rate?: string | null;
    low_balance_threshold: string;
    markup_multiplier: string;
    max_charge?: string | null;
    max_queries_per_minute?: number | null;
    min_charge: string;
    /**
     * Minimum price to display in UI for passthrough publishers (informational only)
     */
    min_display_price?: string | null;
    minimum_balance: string;
    onchain_enabled: boolean;
    payment_expiry_minutes: number;
    prepaid_enabled: boolean;
    price_per_call?: string | null;
    price_per_delete?: string | null;
    /**
     * Price per execution for agent templates or usage-based billing
     */
    price_per_execution?: string | null;
    price_per_get?: string | null;
    price_per_patch?: string | null;
    price_per_post?: string | null;
    price_per_put?: string | null;
    /**
     * Text to display for variable pricing (e.g., "Varies by model")
     */
    pricing_display_text?: string | null;
    pricing_model: PricingModel;
};

/**
 * Pricing model used to interpret pricing units.
 */
export type PricingModel = 'per_row' | 'per_request' | 'per_byte' | 'tiered' | 'passthrough';

/**
 * Simplified pricing summary for suggestions
 */
export type PricingSummary = {
    base_price_per_1000_rows?: string | null;
};

/**
 * Project represents a SerenDB database instance
 */
export type Project = {
    active_time_seconds?: number;
    block_public_connections: boolean;
    block_vpc_connections: boolean;
    branch_count?: number;
    compute_last_active_at?: string | null;
    compute_unit_max: number;
    compute_unit_min: number;
    created_at: string;
    created_by: string;
    default_branch_id?: string | null;
    default_compute_size_max?: number;
    default_compute_size_min?: number;
    deleted_at?: string | null;
    deleted_by?: string | null;
    enable_logical_replication?: boolean;
    hipaa: boolean;
    history_retention_seconds?: number;
    id: string;
    name: string;
    organization_id: string;
    postgres_version?: string;
    protected_branches_only: boolean;
    region: string;
    storage_bytes?: number;
    tenant_id: string;
    updated_at: string;
};

export type ProjectConnectionUriQuery = {
    /**
     * Branch ID to target (defaults to project's default branch)
     */
    branch_id?: string | null;
    /**
     * Database name override (currently ignored)
     */
    database_name?: string | null;
    /**
     * Endpoint ID to target (defaults to first endpoint in branch)
     */
    endpoint_id?: string | null;
    /**
     * Return pooled connection (currently ignored)
     */
    pooled?: boolean | null;
    /**
     * Role name override (currently ignored)
     */
    role_name?: string | null;
};

export type ProjectConnectionUriResponse = {
    uri: string;
};

/**
 * ProjectConsumption wraps consumption data for API responses
 */
export type ProjectConsumption = {
    current_month: ConsumptionSummary;
    from: string;
    periods: Array<ConsumptionPeriodData>;
    project_id: string;
    to: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ProjectConsumptionResponse = {
    data: ProjectConsumption;
    pagination?: PaginationMeta | null;
};

/**
 * Response after creating a project
 */
export type ProjectCreated = {
    block_public_connections: boolean;
    block_vpc_connections: boolean;
    branch_count?: number;
    compute_unit_max: number;
    compute_unit_min: number;
    created_at: string;
    /**
     * The main branch for this project
     */
    default_branch_id?: string | null;
    /**
     * Whether logical replication is enabled for this project
     */
    enable_logical_replication?: boolean;
    hipaa: boolean;
    id: string;
    name: string;
    organization_id: string;
    postgres_version?: string;
    protected_branches_only: boolean;
    region: string;
    storage_bytes?: number;
    tenant_id: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ProjectCreatedResponse = {
    data: ProjectCreated;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ProjectResponse = {
    data: Project;
    pagination?: PaginationMeta | null;
};

/**
 * Response for project storage size
 */
export type ProjectSize = {
    project_id: string;
    size_bytes: number;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ProjectSizeResponse = {
    data: ProjectSize;
    pagination?: PaginationMeta | null;
};

export type ProjectVpcEndpointAssignment = {
    created_at: string;
    endpoint_id: string;
    endpoint_label?: string | null;
    id: string;
    label?: string | null;
    organization_vpc_endpoint_id: string;
    project_id: string;
    region: string;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ProjectVpcEndpointAssignmentResponse = {
    data: ProjectVpcEndpointAssignment;
    pagination?: PaginationMeta | null;
};

/**
 * A promotional code that can be redeemed for credits
 */
export type PromoCode = {
    code: string;
    created_at: string;
    created_by?: string | null;
    credit_amount_usd: string;
    credit_expires_days?: number | null;
    description?: string | null;
    id: string;
    is_active: boolean;
    max_redemptions?: number | null;
    one_per_org: boolean;
    updated_at: string;
    valid_from?: string | null;
    valid_until?: string | null;
};

/**
 * A record of a promo code redemption
 */
export type PromoCodeRedemption = {
    created_at: string;
    credit_grant_id: string;
    id: string;
    organization_id: string;
    promo_code_id: string;
    redeemed_by?: string | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PromoCodeRedemptionsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<PromoCodeRedemption>;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PromoCodeResponse = {
    data: PromoCode;
    pagination?: PaginationMeta | null;
};

/**
 * Promo code with redemption count for admin views
 */
export type PromoCodeWithStats = PromoCode & {
    redemption_count: number;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PromoCodesWithStatsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<PromoCodeWithStats>;
    pagination?: PaginationMeta | null;
};

export type ProvidersResponse = {
    providers: Array<PublisherOAuthProviderResponse>;
};

/**
 * Asset info returned to proxy for metering and settlement.
 */
export type ProxyAssetInfo = {
    /**
     * Asset decimals
     */
    asset_decimals: number;
    /**
     * Asset ID
     */
    asset_id: string;
    /**
     * Asset symbol (e.g., "USDC")
     */
    asset_symbol: string;
    /**
     * Token contract address (EVM) or mint address (Solana) when applicable.
     */
    contract_address?: string | null;
    /**
     * Network identifier (CAIP-2)
     */
    network_id: string;
};

/**
 * Agent balance info returned to proxy
 */
export type ProxyBalanceInfo = {
    /**
     * Available balance (balance - reserved)
     */
    available_atomic: number;
    /**
     * Balance in atomic units
     */
    balance_atomic: number;
    /**
     * Reserved balance in atomic units
     */
    reserved_atomic: number;
};

/**
 * Pricing info returned to proxy
 */
export type ProxyPricingInfo = {
    /**
     * Base price per 1000 rows (configured asset)
     */
    base_price_per_1000_rows: number;
    /**
     * Markup multiplier
     */
    markup_multiplier: number;
    /**
     * Maximum charge (configured asset)
     */
    max_charge?: number | null;
    /**
     * Minimum charge (configured asset)
     */
    min_charge: number;
    /**
     * Whether on-chain payments are accepted
     */
    onchain_enabled: boolean;
    /**
     * Whether prepaid balance is accepted
     */
    prepaid_enabled: boolean;
    pricing_model: PricingModel;
};

/**
 * Publisher info returned to proxy
 */
export type ProxyPublisherInfo = {
    /**
     * Connection string (decrypted)
     */
    connection_string: string;
    /**
     * Default database name
     */
    database_name: string;
    /**
     * Publisher ID
     */
    publisher_id: string;
    /**
     * Publisher name
     */
    publisher_name: string;
    /**
     * Publisher slug
     */
    publisher_slug: string;
    /**
     * PostgreSQL role to use
     */
    role_name: string;
};

/**
 * Publication response (API output)
 */
export type PublicationInfo = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    project_id: string;
    publish_delete: boolean;
    publish_insert: boolean;
    publish_truncate: boolean;
    publish_update: boolean;
    /**
     * Tables to replicate (empty means ALL TABLES)
     */
    tables: Array<string>;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PublicationInfoResponse = {
    data: PublicationInfo;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PublicationsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<PublicationInfo>;
    pagination?: PaginationMeta | null;
};

/**
 * Response for publisher analytics
 */
export type PublisherAnalyticsResponse = {
    publisher_id: string;
    templates: Array<TemplateAnalytics>;
    totals: PublisherAnalyticsTotals;
};

/**
 * Aggregated totals for publisher analytics
 */
export type PublisherAnalyticsTotals = {
    failed_invocations: number;
    overall_success_rate: number;
    successful_invocations: number;
    total_invocations: number;
    total_revenue_atomic: number;
    total_revenue_usd: number;
    total_templates: number;
    unique_agents_served: number;
};

/**
 * Publisher category - the primary classification of what a publisher offers
 */
export type PublisherCategory = 'database' | 'integration' | 'compute';

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PublisherDataResponse = {
    data: PublisherResponse;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PublisherEarningsDataResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<PublisherEarningsResponse>;
    pagination?: PaginationMeta | null;
};

/**
 * Publisher earnings summary response (per asset).
 */
export type PublisherEarningsResponse = {
    asset: AssetInfo;
    available: number;
    available_atomic: number;
    pending_payout: number;
    pending_payout_atomic: number;
    publisher_id: string;
    publisher_name: string;
    publisher_slug: string;
    request_count: number;
    total_revenue: number;
    total_revenue_atomic: number;
    total_withdrawn: number;
    total_withdrawn_atomic: number;
    wallet_address: WalletAddress;
};

/**
 * Response type for OAuth provider (excludes sensitive fields)
 */
export type PublisherOAuthProviderResponse = {
    created_at: string;
    description?: string | null;
    id: string;
    is_active: boolean;
    logo_url?: string | null;
    name: string;
    organization_id?: string | null;
    scopes: Array<string>;
    slug: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PublisherPayoutDataResponse = {
    data: PublisherPayoutResponse;
    pagination?: PaginationMeta | null;
};

/**
 * Publisher payout response.
 */
export type PublisherPayoutResponse = {
    amount: number;
    amount_atomic: number;
    asset: AssetInfo;
    destination_wallet: WalletAddress;
    error_message?: string | null;
    id: string;
    publisher_id: string;
    requested_at: string;
    status: PayoutStatus;
    tx_hash?: string | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PublisherPayoutsDataResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<PublisherPayoutResponse>;
    pagination?: PaginationMeta | null;
};

/**
 * Publisher response (excludes sensitive fields)
 */
export type PublisherResponse = {
    /**
     * Accepted assets for payment
     */
    accepted_assets?: Array<AssetInfo> | null;
    allowed_passthrough_headers: Array<string>;
    /**
     * Header name to inject upstream_api_key into (e.g., "Authorization", "X-API-Key")
     */
    api_key_header?: string | null;
    /**
     * Query parameter name to inject upstream_api_key into (e.g., "api_key", "apiKey")
     */
    api_key_query_param?: string | null;
    /**
     * External API URL (for integration_type = api)
     */
    api_url?: string | null;
    billing_model: string;
    /**
     * SerenDB branch ID (for database_type = serendb)
     */
    branch_id?: string | null;
    /**
     * Publisher-declared capabilities for task matching
     */
    capabilities: Array<string>;
    categories: Array<string>;
    compute_type?: ComputeType | null;
    created_at: string;
    /**
     * Provider config (sensitive fields redacted)
     */
    database_config?: unknown;
    /**
     * Database name within the SerenDB project
     */
    database_name?: string | null;
    database_type?: DatabaseType | null;
    description?: string | null;
    /**
     * Publisher contact email for notifications and support
     */
    email?: string | null;
    /**
     * Structured endpoint definitions for LLM discoverability and access control
     */
    endpoints?: Array<EndpointDefinition> | null;
    gateway_fee_percent: string;
    id: string;
    integration_type?: IntegrationType | null;
    is_active: boolean;
    is_verified: boolean;
    logo_url?: string | null;
    /**
     * Cached MCP capabilities (tools, resources, prompts)
     */
    mcp_capabilities?: unknown;
    /**
     * MCP server endpoint URL (for integration_type = mcp)
     */
    mcp_endpoint?: string | null;
    name: string;
    /**
     * OAuth provider ID for BYOC (Bring Your Own Credentials) authentication
     */
    oauth_provider_id?: string | null;
    ownership_tracking_enabled: boolean;
    /**
     * Pricing config per asset (if included)
     */
    pricing?: Array<PricingConfigResponse> | null;
    /**
     * SerenDB project ID (for database_type = serendb)
     */
    project_id?: string | null;
    protected_operations?: unknown;
    publisher_category: PublisherCategory;
    publisher_type: PublisherType;
    /**
     * Content-Type for upstream API requests
     */
    request_content_type: string;
    /**
     * If true, users must connect via OAuth before using this publisher
     */
    requires_user_oauth: boolean;
    resource_description?: string | null;
    resource_id_response_path?: string | null;
    resource_id_url_pattern?: string | null;
    resource_name?: string | null;
    slug: string;
    /**
     * TTL for cached exchanged tokens in seconds
     */
    token_cache_ttl_seconds?: number | null;
    /**
     * HTTP method for exchange endpoint (POST or GET)
     */
    token_exchange_method?: string | null;
    /**
     * How to send Seren token: header, body, or query
     */
    token_exchange_mode?: string | null;
    /**
     * URL to call for exchanging Seren API keys for publisher auth tokens
     */
    token_exchange_url?: string | null;
    /**
     * JSON field in exchange response containing the token
     */
    token_response_field?: string | null;
    total_queries: number;
    undocumented_endpoint_policy: UndocumentedEndpointPolicy;
    unique_agents_served: number;
    updated_at: string;
    /**
     * Dot-separated path to upstream cost in response body (for prepaid passthrough billing).
     * Example: "usage.cost"
     */
    upstream_cost_response_path?: string | null;
    /**
     * Non-sensitive headers to send to upstream API
     */
    upstream_headers: unknown;
    /**
     * Usage examples showing how to call the publisher's API
     */
    usage_examples?: Array<UsageExample> | null;
    /**
     * Human-readable use case descriptions
     */
    use_cases: Array<string>;
    /**
     * When verification expires (NULL = no expiry)
     */
    verification_expires_at?: string | null;
    wallet_address: WalletAddress;
    /**
     * Network for the wallet address
     */
    wallet_network_id: string;
};

/**
 * A publisher suggestion with match score and reason
 */
export type PublisherSuggestion = {
    /**
     * Publisher-declared capabilities
     */
    capabilities: Array<string>;
    description?: string | null;
    /**
     * Why this publisher was suggested
     */
    match_reason: string;
    name: string;
    pricing?: PricingSummary | null;
    /**
     * Match score (0.0 to 1.0)
     */
    score: number;
    slug: string;
};

/**
 * Type of publisher in the store
 */
export type PublisherType = 'individual' | 'organization' | 'verified_partner';

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type PublishersDataResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<PublisherResponse>;
    pagination?: PaginationMeta | null;
};

/**
 * Query parameter definition for an endpoint
 */
export type QueryParamDefinition = {
    /**
     * Human-readable description
     */
    description?: string | null;
    /**
     * Example value for documentation
     */
    example?: string | null;
    /**
     * Parameter name (e.g., "id", "limit")
     */
    name: string;
    param_type?: ParamType;
    /**
     * Whether this parameter is required
     */
    required?: boolean;
};

/**
 * Query request body
 */
export type QueryRequestBody = {
    /**
     * Optional asset id to pay with (defaults to publisher primary asset)
     */
    asset_id?: string | null;
    /**
     * Optional database name
     */
    database?: string | null;
    /**
     * Publisher slug (alternative to `publisher_id`)
     */
    publisher?: string | null;
    /**
     * Publisher UUID (required if `publisher` slug not provided)
     */
    publisher_id?: string | null;
    /**
     * SQL query to execute
     */
    query: string;
    /**
     * Optional idempotency key (UUID) for deduplication
     */
    request_id?: string | null;
};

/**
 * Query result response
 */
export type QueryResultResponse = {
    /**
     * Asset symbol (e.g., USDC, USDT)
     */
    asset_symbol: string;
    /**
     * Actual cost charged in configured asset
     */
    cost: string;
    /**
     * Execution time in milliseconds
     */
    execution_time_ms: number;
    /**
     * Payment source used
     */
    payment_source: string;
    /**
     * Number of rows returned
     */
    row_count: number;
    /**
     * Query result rows as JSON
     */
    rows: Array<unknown>;
};

/**
 * Enum for quota check results
 */
export type QuotaCheckResult = 'Allowed' | {
    /**
     * Operation would exceed quota
     */
    QuotaExceeded: {
        current: number;
        limit: number;
        message: string;
        quota_type: string;
    };
} | 'NoPlanFound';

/**
 * Quota usage summary for an organization
 */
export type QuotaUsage = {
    compute_hours_usage_percent?: number | null;
    current_branches: number;
    current_compute_hours: number;
    current_projects: number;
    current_storage_gb: number;
    is_over_compute_quota: boolean;
    is_over_projects_quota: boolean;
    is_over_storage_quota: boolean;
    organization_id: string;
    plan: Plan;
    projects_usage_percent?: number | null;
    storage_usage_percent?: number | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type QuotaUsageResponse = {
    data: QuotaUsage;
    pagination?: PaginationMeta | null;
};

/**
 * Response after creating or updating a role
 */
export type RbacRole = {
    created_at: string;
    description?: string | null;
    id: string;
    is_built_in: boolean;
    name: string;
    permissions: Array<string>;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type RbacRoleResponse = {
    data: RbacRole;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type RbacRolesResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<RbacRole>;
    pagination?: PaginationMeta | null;
};

/**
 * Request to read a resource from an MCP publisher
 */
export type ReadMcpResourceRequest = {
    /**
     * Publisher slug or ID
     */
    publisher?: string | null;
    /**
     * Publisher UUID (alternative to slug)
     */
    publisher_id?: string | null;
    /**
     * URI of the resource to read
     */
    uri: string;
};

/**
 * Request to redeem a promo code (user)
 */
export type RedeemPromoCodeRequest = {
    code: string;
};

/**
 * Wrapped referral info response for OpenAPI
 */
export type ReferralInfoDataResponse = {
    data: ReferralInfoResponse;
};

/**
 * Response for referral info
 */
export type ReferralInfoResponse = {
    pending_earnings_atomic: number;
    pending_earnings_usd: string;
    referral_code: string;
    referral_url: string;
    total_earnings_atomic: number;
    total_earnings_usd: string;
    total_referrals: number;
};

export type RefundTransactionRequest = {
    amount: number;
    endpoint_id: string;
    reason: string;
    timestamp: number;
    transaction_id: string;
    user_id?: string | null;
};

export type RefundTransactionResponse = {
    new_balance: number;
    refund_id: string;
};

/**
 * Query parameters for filtering VPC endpoints.
 */
export type RegionQuery = {
    /**
     * Filter endpoints by region
     */
    region?: string | null;
};

/**
 * Request to rename a branch
 */
export type RenameBranchRequest = {
    name: string;
};

/**
 * Replication slot response (API output)
 */
export type ReplicationSlotInfo = {
    active_pid?: number | null;
    branch_id: string;
    confirmed_flush_lsn?: string | null;
    created_at: string;
    id: string;
    name: string;
    plugin: string;
    project_id: string;
    restart_lsn?: string | null;
    slot_type: string;
    status: string;
    updated_at: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ReplicationSlotInfoResponse = {
    data: ReplicationSlotInfo;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type ReplicationSlotsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<ReplicationSlotInfo>;
    pagination?: PaginationMeta | null;
};

export type ResendVerificationRequest = {
    email: Email;
};

/**
 * Request to reset a branch to its parent's latest state
 */
export type ResetBranchRequest = {
    /**
     * Whether to reset to parent (currently the only supported option)
     */
    parent: boolean;
};

/**
 * Entry used when resetting the IP allow list
 */
export type ResetIpAllowListEntry = {
    /**
     * Optional description for the entry
     */
    description?: string | null;
    /**
     * IP address or CIDR range to allow
     */
    ip_address: string;
};

/**
 * Request to replace the entire IP allow list
 */
export type ResetIpAllowListRequest = {
    /**
     * Entries that should remain in the allow list after the reset.
     * Empty list means the allow list is cleared.
     */
    entries?: Array<ResetIpAllowListEntry>;
};

export type ResetPasswordRequest = {
    new_password: string;
    token: string;
};

/**
 * Request to reset a role's password
 */
export type ResetRolePasswordRequest = {
    password: string;
};

/**
 * Resource information for x402 V2
 *
 * In V2, resource metadata is a top-level field rather than being
 * embedded in each payment requirement.
 */
export type ResourceInfo = {
    /**
     * Human-readable description of the resource
     */
    description: string;
    /**
     * MIME type of the resource response
     */
    mimeType: string;
    /**
     * URL of the resource being paid for
     */
    url: string;
};

/**
 * Request to restore a branch to a point in time
 */
export type RestoreBranchRequest = {
    /**
     * Name for the backup branch that will preserve the current state
     */
    preserve_under_name: string;
    source: RestoreSource;
};

/**
 * Restore source for point-in-time recovery
 */
export type RestoreSource = {
    point_in_time: PointInTime;
    type: '^self';
} | {
    point_in_time?: PointInTime | null;
    type: '^parent';
} | {
    point_in_time?: PointInTime | null;
    source_branch_id: string;
    type: 'branch';
};

/**
 * Revenue breakdown by day.
 */
export type RevenueByDay = {
    /**
     * Date (YYYY-MM-DD)
     */
    date: string;
    /**
     * Number of queries on this day
     */
    query_count: number;
    /**
     * Revenue as decimal string
     */
    revenue: string;
    /**
     * Revenue on this day (atomic units)
     */
    revenue_atomic: number;
    /**
     * Number of unique agents on this day
     */
    unique_agents: number;
};

/**
 * Revenue metrics with period-over-period comparison.
 */
export type RevenueMetrics = {
    /**
     * Number of active agents in the period
     */
    active_agents: number;
    /**
     * Agent count change from previous period (percentage)
     */
    agents_change_pct: number;
    /**
     * Average query cost (atomic units)
     */
    avg_query_cost_atomic: number;
    /**
     * Period end date (ISO 8601)
     */
    period_end: string;
    /**
     * Period start date (ISO 8601)
     */
    period_start: string;
    /**
     * Query count change from previous period (percentage)
     */
    queries_change_pct: number;
    /**
     * Revenue change from previous period (percentage, e.g., 15 = +15%)
     */
    revenue_change_pct: number;
    /**
     * Total queries executed in the period
     */
    total_queries: number;
    /**
     * Total revenue as decimal string
     */
    total_revenue: string;
    /**
     * Total revenue in the period (atomic units)
     */
    total_revenue_atomic: number;
};

export type RevokeResponse = {
    message: string;
    success: boolean;
};

/**
 * PostgreSQL role/user within a SerenDB branch
 */
export type Role = {
    branch_id: string;
    created_at: string;
    /**
     * User who created the role. None for roles created via SQL on compute (DDL sync).
     */
    created_by?: string | null;
    deleted_at?: string | null;
    deleted_by?: string | null;
    id: string;
    /**
     * System roles (like cloud_admin) are hidden from users
     */
    is_system: boolean;
    name: string;
    password_ciphertext?: Blob | File | null;
    password_nonce?: Blob | File | null;
    protected: boolean;
    scram_secret?: string | null;
    updated_at: string;
};

/**
 * Response after creating a role
 */
export type RoleCreated = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    password: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type RoleCreatedResponse = {
    data: RoleCreated;
    pagination?: PaginationMeta | null;
};

/**
 * Public role info (without password hash)
 */
export type RoleInfo = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    protected: boolean;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type RoleInfoResponse = {
    data: RoleInfo;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type RoleInfosResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<RoleInfo>;
    pagination?: PaginationMeta | null;
};

/**
 * Response after resetting password
 */
export type RolePasswordReset = {
    password: string;
    role_id: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type RolePasswordResetResponse = {
    data: RolePasswordReset;
    pagination?: PaginationMeta | null;
};

/**
 * Response for listing user sessions (hides sensitive token hash)
 */
export type Session = {
    created_at: string;
    expires_at: string;
    id: string;
    ip_address?: string | null;
    is_current: boolean;
    last_active_at: string;
    user_agent?: string | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type SessionsResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<Session>;
    pagination?: PaginationMeta | null;
};

export type SessionsRevoked = {
    message: string;
    revoked_count: number;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type SessionsRevokedResponse = {
    data: SessionsRevoked;
    pagination?: PaginationMeta | null;
};

/**
 * Request to set branch archived status
 */
export type SetBranchArchivedRequest = {
    archived: boolean;
};

/**
 * Request to set branch expiration
 */
export type SetBranchExpirationRequest = {
    expires_at?: string | null;
};

/**
 * Settlement response - returned in PAYMENT-RESPONSE (v2) / X-PAYMENT-RESPONSE (v1) headers (base64 encoded)
 */
export type SettlementResponse = {
    /**
     * Error reason if settlement failed (omitted if successful)
     */
    errorReason?: string | null;
    /**
     * Network where payment was processed
     */
    network: string;
    /**
     * Payer wallet address
     */
    payer?: string | null;
    /**
     * Whether payment was accepted
     */
    success: boolean;
    /**
     * Blockchain transaction hash (empty string if settlement failed)
     */
    transaction: string;
};

/**
 * A validated URL-safe slug.
 *
 * Slugs must be:
 * - 2-64 characters long
 * - Lowercase alphanumeric with hyphens
 * - Cannot start or end with a hyphen
 * - Cannot have consecutive hyphens
 *
 * # Examples
 *
 * ```
 * use seren_core::models::Slug;
 *
 * let slug = Slug::new("my-project").unwrap();
 * assert!(Slug::new("My Project").is_err()); // spaces not allowed
 * assert!(Slug::new("-invalid").is_err()); // can't start with hyphen
 * ```
 */
export type Slug = string;

/**
 * Supported asset for streaming authorization
 */
export type StreamingAsset = {
    /**
     * Asset contract address
     */
    address: string;
    /**
     * Internal asset ID (for clients that want to request a specific asset)
     */
    asset_id?: string | null;
    /**
     * Asset decimals
     */
    decimals: number;
    eip712?: Eip712Domain | null;
    /**
     * Whether this is the publisher's primary streaming asset.
     */
    is_primary?: boolean | null;
    /**
     * Network identifier (CAIP-2, e.g., "eip155:8453")
     */
    network: string;
    /**
     * Asset symbol (e.g., "USDC")
     */
    symbol: string;
};

/**
 * Extra metadata for streaming authorization (x402-aligned)
 */
export type StreamingAuthExtra = {
    eip712: Eip712Domain;
    /**
     * Unique request ID for tracking this authorization request
     */
    request_id: string;
    /**
     * Token name for EIP-712 domain
     */
    token_name: string;
    /**
     * Token version for EIP-712 domain
     */
    token_version: string;
};

/**
 * DataResponse wrapper for streaming auth requirements (for OpenAPI schema)
 */
export type StreamingAuthRequirementsDataResponse = {
    data: StreamingAuthRequirementsResponse;
};

/**
 * Response for streaming authorization requirements
 *
 * This endpoint returns the information agents need to create their
 * EIP-3009 `TransferWithAuthorization` signature for streaming payments.
 */
export type StreamingAuthRequirementsResponse = {
    /**
     * Chain ID for EIP-712 signing
     */
    chain_id: number;
    extra: StreamingAuthExtra;
    /**
     * Minimum authorization amount in atomic units
     */
    min_authorization: string;
    /**
     * Address to authorize payment TO (Seren's settlement wallet)
     * This is the `to` address in EIP-3009 TransferWithAuthorization
     */
    pay_to: string;
    pricing: StreamingPricing;
    /**
     * Publisher slug
     */
    publisher_slug: string;
    /**
     * Suggested authorization amount in atomic units
     */
    suggested_authorization: string;
    /**
     * Supported payment assets
     */
    supported_assets: Array<StreamingAsset>;
};

/**
 * Pricing information for streaming authorization
 */
export type StreamingPricing = {
    /**
     * Base cost per query in atomic units
     */
    base_cost_per_query: string;
    /**
     * Cost per byte in atomic units
     */
    cost_per_byte: string;
    /**
     * Cost per row in atomic units
     */
    cost_per_row: string;
};

/**
 * A Stripe Charge ID (ch_xxx).
 */
export type StripeChargeId = string;

/**
 * A Stripe Customer ID (cus_xxx).
 */
export type StripeCustomerId = string;

/**
 * A Stripe Payment Intent ID (pi_xxx).
 */
export type StripePaymentIntentId = string;

/**
 * A Stripe Payment Method ID (pm_xxx).
 */
export type StripePaymentMethodId = string;

/**
 * A Stripe Price ID (price_xxx).
 */
export type StripePriceId = string;

/**
 * A Stripe Subscription ID (sub_xxx).
 */
export type StripeSubscriptionId = string;

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type SuggestDataResponse = {
    data: SuggestResponse;
    pagination?: PaginationMeta | null;
};

/**
 * Query parameters for suggesting publishers based on task/query
 */
export type SuggestParams = {
    /**
     * Maximum number of results (default: 5, max: 20)
     */
    limit?: number;
    /**
     * The task or query to match against publisher capabilities.
     * Examples: "scrape website", "AI research", "PDF extraction"
     */
    query: string;
    /**
     * Type of suggestions: "publisher", "agent", or "both" (default: "both")
     * Note: Agent suggestions are planned but not yet implemented.
     */
    type?: string;
};

/**
 * Response for suggest endpoint
 * Returns publisher and agent recommendations based on task/query matching
 */
export type SuggestResponse = {
    /**
     * Matched agents sorted by relevance (agent templates coming soon)
     */
    agents: Array<unknown>;
    /**
     * Matched publishers sorted by relevance
     */
    publishers: Array<PublisherSuggestion>;
};

/**
 * Supported payment kind (from facilitator /supported endpoint)
 */
export type SupportedKind = {
    /**
     * Extra scheme-specific info
     */
    extra?: unknown;
    /**
     * Network in CAIP-2 format
     */
    network: string;
    /**
     * Payment scheme
     */
    scheme: string;
    /**
     * x402 protocol version
     */
    x402Version: number;
};

/**
 * Response from facilitator /supported endpoint
 */
export type SupportedResponse = {
    /**
     * List of supported extensions
     */
    extensions?: Array<string> | null;
    /**
     * List of supported payment kinds
     */
    kinds: Array<SupportedKind>;
    /**
     * Signer addresses by network family
     */
    signers?: unknown;
};

/**
 * Analytics data for a single template
 */
export type TemplateAnalytics = {
    avg_execution_time_ms?: number | null;
    failed_invocations: number;
    name: string;
    slug: string;
    success_rate: number;
    successful_invocations: number;
    template_id: string;
    total_invocations: number;
    total_revenue_atomic: number;
    total_revenue_usd: number;
    unique_agents_served: number;
};

/**
 * Response wrapper for template data
 */
export type TemplateDataResponse = {
    data: CreateTemplateResponse;
};

/**
 * Programming language for agent templates
 */
export type TemplateLanguage = 'python' | 'typescript' | 'rust';

/**
 * Response wrapper for template list
 */
export type TemplateListResponse = {
    data: Array<AgentTemplateSummary>;
    total: number;
};

/**
 * Sorting options for template catalog
 */
export type TemplateSortBy = 'popularity' | 'price_asc' | 'price_desc' | 'newest' | 'oldest';

/**
 * Response for timestamp by LSN query
 */
export type TimestampByLsn = {
    timestamp: string;
};

/**
 * Query parameters for getting timestamp by LSN.
 */
export type TimestampByLsnQuery = {
    /**
     * Log Sequence Number (e.g., 0/1234567)
     */
    lsn: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type TimestampByLsnResponse = {
    data: TimestampByLsn;
    pagination?: PaginationMeta | null;
};

/**
 * Top agent by spending.
 */
export type TopAgent = {
    /**
     * Agent wallet address
     */
    agent_wallet: string;
    /**
     * Current balance (atomic units)
     */
    balance_atomic: number;
    /**
     * Last activity timestamp (ISO 8601)
     */
    last_active?: string | null;
    /**
     * Number of queries executed
     */
    query_count: number;
    /**
     * Rank (1 = highest spender)
     */
    rank: number;
    /**
     * Total amount spent as decimal string
     */
    total_spent: string;
    /**
     * Total amount spent (atomic units)
     */
    total_spent_atomic: number;
};

export type TopAgentsQueryParams = {
    /**
     * Number of agents to return (default: 10)
     */
    limit?: number;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type TransactionDataResponse = {
    data: TransactionResponse;
    pagination?: PaginationMeta | null;
};

/**
 * Query parameters for transaction history
 */
export type TransactionHistoryParams = {
    /**
     * Maximum number of results (default: 50, max: 100)
     */
    limit?: number;
    /**
     * Offset for pagination
     */
    offset?: number;
    /**
     * Filter by publisher
     */
    publisher_id?: string | null;
};

/**
 * Query params for transaction history
 */
export type TransactionHistoryQuery = {
    /**
     * Maximum number of transactions to return (default 50, max 100)
     */
    limit?: number;
    /**
     * Offset for pagination
     */
    offset?: number;
};

/**
 * Transaction history response
 */
export type TransactionResponse = {
    agent_wallet: WalletAddress;
    /**
     * Amount in asset decimal units (positive = credit, negative = debit)
     */
    amount: number;
    /**
     * Amount in atomic units (for precision)
     */
    amount_atomic: number;
    asset: AssetInfo;
    /**
     * Balance after transaction in asset decimal units
     */
    balance_after: number;
    created_at: string;
    description?: string | null;
    id: string;
    payment_source?: PaymentSource | null;
    publisher_id: string;
    transaction_type: TransactionType;
    tx_hash?: string | null;
};

/**
 * Transaction type for audit log
 */
export type TransactionType = 'deposit' | 'query_charge' | 'api_call' | 'refund' | 'withdrawal' | 'settlement' | 'service_fee';

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type TransactionsDataResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<TransactionResponse>;
    pagination?: PaginationMeta | null;
};

/**
 * Single typed parameter definition
 */
export type TypedParam = {
    name: string;
    type: string;
};

/**
 * Policy for handling requests to paths not in the endpoints catalog
 */
export type UndocumentedEndpointPolicy = 'default_allow' | 'default_deny';

/**
 * Request to update branch protection
 */
export type UpdateBranchProtectionRequest = {
    allowed_bypass_roles?: Array<string> | null;
    prevent_deletion?: boolean | null;
    prevent_reset?: boolean | null;
    require_approval_for_changes?: boolean | null;
};

/**
 * Request to update a database
 */
export type UpdateDatabaseRequest = {
    owner_name?: string | null;
};

/**
 * Request to update an endpoint
 */
export type UpdateEndpointRequest = {
    autoscaling_max?: number | null;
    autoscaling_min?: number | null;
    pooler_enabled?: boolean | null;
    pooler_mode?: PoolerMode | null;
    suspend_timeout_seconds?: number | null;
};

/**
 * Request to update organization limits
 */
export type UpdateLimitsRequest = {
    branches?: number | null;
    compute_hours?: number | null;
    data_transfer_gb?: number | null;
    logical_size_bytes?: number | null;
    projects?: number | null;
    storage_gb?: number | null;
};

/**
 * Request to update logical replication settings
 */
export type UpdateLogicalReplicationRequest = {
    enabled: boolean;
};

/**
 * Request to update an OAuth provider (admin only).
 *
 * Fields use `Option<Option<T>>` where `null` explicitly clears the value.
 */
export type UpdateOAuthProviderRequest = {
    authorization_url?: string | null;
    client_id?: string | null;
    /**
     * Optional new client secret (will be re-encrypted). If omitted, keep existing.
     */
    client_secret?: string | null;
    /**
     * If omitted, leave unchanged. If null, clear.
     */
    description?: string | null;
    is_active?: boolean | null;
    /**
     * If omitted, leave unchanged. If null, clear.
     */
    logo_url?: string | null;
    name?: string | null;
    pkce_required?: boolean | null;
    /**
     * If omitted, leave unchanged. If null, clear.
     */
    revocation_url?: string | null;
    scopes?: Array<string> | null;
    slug?: string | null;
    token_endpoint_auth_method?: string | null;
    token_url?: string | null;
    /**
     * If omitted, leave unchanged. If null, clear.
     */
    userinfo_url?: string | null;
};

/**
 * Request to update pricing config
 */
export type UpdatePricingRequest = {
    /**
     * Asset ID for this pricing config (required)
     */
    asset_id: string;
    base_price_per_1000_rows?: string | null;
    grace_period_minutes?: number | null;
    hourly_rate?: string | null;
    low_balance_threshold?: string | null;
    markup_multiplier?: string | null;
    max_charge?: string | null;
    max_queries_per_minute?: number | null;
    min_charge?: string | null;
    /**
     * Minimum price to display in UI for passthrough publishers (informational only)
     */
    min_display_price?: string | null;
    minimum_balance?: string | null;
    onchain_enabled?: boolean | null;
    payment_expiry_minutes?: number | null;
    prepaid_enabled?: boolean | null;
    price_per_call?: string | null;
    price_per_delete?: string | null;
    /**
     * Price per execution for agent templates or usage-based billing
     */
    price_per_execution?: string | null;
    price_per_get?: string | null;
    price_per_patch?: string | null;
    price_per_post?: string | null;
    price_per_put?: string | null;
    /**
     * Text to display for variable pricing (e.g., "Varies by model")
     */
    pricing_display_text?: string | null;
    pricing_model?: PricingModel | null;
    /**
     * TTL for cached exchanged tokens in seconds (60-86400)
     */
    token_cache_ttl_seconds?: number | null;
    /**
     * HTTP method for exchange endpoint (POST or GET)
     */
    token_exchange_method?: string | null;
    /**
     * How to send Seren token: header, body, or query
     */
    token_exchange_mode?: string | null;
    /**
     * URL to call for exchanging Seren API keys for publisher auth tokens
     */
    token_exchange_url?: string | null;
    /**
     * JSON field in exchange response containing the token
     */
    token_response_field?: string | null;
};

/**
 * Request to update a project
 */
export type UpdateProjectRequest = {
    block_public_connections?: boolean | null;
    block_vpc_connections?: boolean | null;
    compute_unit_max?: number | null;
    compute_unit_min?: number | null;
    /**
     * Enable logical replication for this project. Sets wal_level=logical for all compute endpoints.
     * Once enabled, this cannot be disabled. Enabling will suspend all active endpoints.
     */
    enable_logical_replication?: boolean | null;
    hipaa?: boolean | null;
    /**
     * History retention period in seconds for point-in-time recovery (PITR).
     * Determines how far back you can create branches from historical data.
     * Default is 21600 (6 hours). Minimum is 3600 (1 hour). Maximum is 2592000 (30 days).
     */
    history_retention_seconds?: number | null;
    name?: string | null;
    protected_branches_only?: boolean | null;
};

/**
 * Request to update a promo code (admin)
 */
export type UpdatePromoCodeRequest = {
    description?: string | null;
    is_active?: boolean | null;
    max_redemptions?: number | null;
    valid_until?: string | null;
};

/**
 * Request to update a publication
 */
export type UpdatePublicationRequest = {
    publish_delete?: boolean | null;
    publish_insert?: boolean | null;
    publish_truncate?: boolean | null;
    publish_update?: boolean | null;
    tables?: Array<string> | null;
};

/**
 * Request to update a publisher
 */
export type UpdatePublisherRequest = {
    /**
     * Asset IDs to add to accepted assets
     */
    add_asset_ids?: Array<string> | null;
    /**
     * Whitelist of agent-provided headers allowed to pass through to upstream
     */
    allowed_passthrough_headers?: Array<string> | null;
    /**
     * Headers for API requests (will be encrypted)
     */
    api_headers?: unknown;
    /**
     * Header name to inject upstream_api_key into (e.g., "Authorization", "X-API-Key")
     */
    api_key_header?: string | null;
    /**
     * Query parameter name to inject upstream_api_key into (e.g., "api_key")
     */
    api_key_query_param?: string | null;
    /**
     * External API URL (for integration_type = api)
     */
    api_url?: string | null;
    /**
     * Upstream auth mode ("static" or "jwt")
     */
    auth_type?: string | null;
    base_price_per_1000_rows?: string | null;
    /**
     * Billing model ("x402_per_request", "prepaid_credits", "x402_passthrough")
     */
    billing_model?: string | null;
    /**
     * SerenDB branch ID (for database_type = serendb)
     */
    branch_id?: string | null;
    /**
     * Publisher-declared capabilities for task matching (e.g., "web_scraping", "ai_search")
     */
    capabilities?: Array<string> | null;
    categories?: Array<string> | null;
    compute_type?: ComputeType | null;
    /**
     * Provider-specific configuration
     */
    database_config?: unknown;
    /**
     * Database name within the SerenDB project
     */
    database_name?: string | null;
    database_type?: DatabaseType | null;
    description?: string | null;
    /**
     * Publisher contact email for notifications and support
     */
    email?: string | null;
    /**
     * Structured endpoint definitions for LLM discoverability and access control
     */
    endpoints?: Array<EndpointDefinition> | null;
    /**
     * Gateway fee percentage for upstream x402 payments (pass-through).
     */
    gateway_fee_percent?: string | null;
    grace_period_minutes?: number | null;
    hourly_rate?: string | null;
    integration_type?: IntegrationType | null;
    is_active?: boolean | null;
    /**
     * JWT access key / issuer claim (plaintext)
     */
    jwt_access_key?: string | null;
    /**
     * JWT signing algorithm ("HS256", "HS384", "HS512")
     */
    jwt_algorithm?: string | null;
    /**
     * JWT expiration seconds
     */
    jwt_expiration_seconds?: number | null;
    /**
     * JWT secret key (will be encrypted)
     */
    jwt_secret_key?: string | null;
    /**
     * Optional publisher branding URL
     */
    logo_url?: string | null;
    low_balance_threshold?: string | null;
    markup_multiplier?: string | null;
    /**
     * MCP server endpoint URL (for integration_type = mcp)
     */
    mcp_endpoint?: string | null;
    minimum_balance?: string | null;
    name?: string | null;
    /**
     * OAuth2 client ID for Client Credentials flow
     */
    oauth2_client_id?: string | null;
    /**
     * OAuth2 client secret for Client Credentials flow (will be encrypted)
     */
    oauth2_client_secret?: string | null;
    /**
     * OAuth2 scopes to request during Client Credentials flow
     */
    oauth2_scopes?: Array<string> | null;
    /**
     * OAuth2 token endpoint URL for Client Credentials flow
     */
    oauth2_token_url?: string | null;
    /**
     * OAuth provider ID for BYOC (Bring Your Own Credentials) authentication.
     * Set to enable user-specific OAuth tokens for this publisher.
     */
    oauth_provider_id?: string | null;
    /**
     * Enable resource ownership tracking (legacy gateway parity)
     */
    ownership_tracking_enabled?: boolean | null;
    price_per_call?: string | null;
    price_per_delete?: string | null;
    /**
     * Price per execution for agent templates or usage-based billing
     */
    price_per_execution?: string | null;
    price_per_get?: string | null;
    price_per_patch?: string | null;
    price_per_post?: string | null;
    price_per_put?: string | null;
    /**
     * SerenDB project ID (for database_type = serendb)
     */
    project_id?: string | null;
    /**
     * Protected operations configuration - legacy, use endpoints[].is_protected instead
     */
    protected_operations?: unknown;
    publisher_category?: PublisherCategory | null;
    /**
     * Asset IDs to remove from accepted assets
     */
    remove_asset_ids?: Array<string> | null;
    /**
     * Content-Type for upstream API requests (default: application/json)
     */
    request_content_type?: string | null;
    /**
     * If true, users must connect via OAuth before using this publisher (BYOC mode).
     * Requires oauth_provider_id to be set.
     */
    requires_user_oauth?: boolean | null;
    resource_description?: string | null;
    /**
     * JSONPath to resource ID in response body (for ownership tracking)
     */
    resource_id_response_path?: string | null;
    /**
     * URL pattern with :resourceId placeholder (for ownership tracking)
     */
    resource_id_url_pattern?: string | null;
    resource_name?: string | null;
    /**
     * TTL for cached exchanged tokens in seconds (60-86400)
     */
    token_cache_ttl_seconds?: number | null;
    /**
     * HTTP method for exchange endpoint (POST or GET)
     */
    token_exchange_method?: string | null;
    /**
     * How to send Seren token: header, body, or query
     */
    token_exchange_mode?: string | null;
    /**
     * URL to call for exchanging Seren API keys for publisher auth tokens
     */
    token_exchange_url?: string | null;
    /**
     * JSON field in exchange response containing the token (default: access_token)
     */
    token_response_field?: string | null;
    undocumented_endpoint_policy?: UndocumentedEndpointPolicy | null;
    /**
     * Upstream static API key (will be encrypted)
     */
    upstream_api_key?: string | null;
    /**
     * Dot-separated path to upstream cost in response body (for prepaid passthrough billing).
     * Example: "usage.cost"
     */
    upstream_cost_response_path?: string | null;
    /**
     * Non-sensitive headers to send to upstream API (e.g., User-Agent)
     */
    upstream_headers?: unknown;
    /**
     * Usage examples showing how to call the publisher's API
     */
    usage_examples?: Array<UsageExample> | null;
    /**
     * Human-readable use case descriptions (e.g., "Scrape dynamic JavaScript websites")
     */
    use_cases?: Array<string> | null;
    wallet_address?: WalletAddress | null;
    /**
     * Network ID for wallet (must be provided if changing wallet_address)
     */
    wallet_network_id?: string | null;
};

/**
 * Request to update a role
 */
export type UpdateRoleRequest = {
    description?: string | null;
    name?: string | null;
    permissions?: Array<string> | null;
};

/**
 * Request to update a webhook
 */
export type UpdateWebhookRequest = {
    enabled?: boolean | null;
    events?: Array<string> | null;
    name?: string | null;
    url?: string | null;
};

/**
 * Debug view: usage_events entry for an endpoint
 */
export type UsageEventDebugRecord = {
    event_timestamp: string;
    event_type: string;
    metadata: string;
    quantity: number;
    unit: string;
};

/**
 * A single usage example showing how to call a publisher's API
 */
export type UsageExample = {
    /**
     * Full curl command example
     */
    curl?: string | null;
    /**
     * Description of what this example demonstrates
     */
    description?: string | null;
    /**
     * Short title for the example (e.g., "Create a collection")
     */
    title?: string | null;
};

export type UsageQueryParams = {
    end_date?: string | null;
    start_date?: string | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type UsageSummariesResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<UsageSummary>;
    pagination?: PaginationMeta | null;
};

/**
 * Usage summary for billing period
 */
export type UsageSummary = {
    compute_cost_usd: number;
    compute_hours_large: number;
    compute_hours_medium: number;
    compute_hours_small: number;
    compute_hours_xlarge: number;
    organization_id: string;
    period_end: string;
    period_start: string;
    pitr_gb_avg: number;
    project_id: string;
    /**
     * Human-readable project name (denormalized for convenience).
     */
    project_name: string;
    /**
     * Cloud region for the project (e.g., aws-us-east-1).
     */
    project_region: string;
    storage_cost_usd: number;
    storage_gb_avg: number;
    total_cost_usd: number;
};

/**
 * Combined user view for API responses
 */
export type UserInfo = {
    avatar_url?: string | null;
    created_at: string;
    email: Email;
    id: string;
    name: string;
    status: UserStatus;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type UserInfoResponse = {
    data: UserInfo;
    pagination?: PaginationMeta | null;
};

/**
 * Response type for user OAuth connection (excludes tokens)
 */
export type UserOAuthConnectionResponse = {
    created_at: string;
    expires_at?: string | null;
    id: string;
    is_valid: boolean;
    last_used_at?: string | null;
    provider_email?: string | null;
    provider_id: string;
    provider_logo_url?: string | null;
    provider_name: string;
    provider_slug: string;
    provider_user_id?: string | null;
    scopes: Array<string>;
};

/**
 * User status enum matching PostgreSQL enum
 */
export type UserStatus = 'active' | 'deleted' | 'disabled' | 'paused';

export type ValidateTokenRequest = {
    endpoint_id?: string | null;
    token: string;
};

export type ValidateTokenResponse = {
    balance: number;
    endpoint_id: string;
    expires_at: number;
    user_id: string;
    valid: boolean;
};

export type VerificationSent = {
    message: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type VerificationSentResponse = {
    data: VerificationSent;
    pagination?: PaginationMeta | null;
};

export type VerifyEmailRequest = {
    token: string;
};

/**
 * A validated wallet address (EVM or Solana).
 *
 * This type ensures wallet addresses are validated at construction time.
 * Stored as TEXT in the database via SQLx's transparent encoding.
 *
 * # Examples
 *
 * ```
 * use seren_core::models::WalletAddress;
 *
 * // EVM address
 * let evm = WalletAddress::new("0x1234567890123456789012345678901234567890").unwrap();
 *
 * // Solana address
 * let sol = WalletAddress::new("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v").unwrap();
 *
 * // Convert to alloy Address for EVM operations
 * if let Some(addr) = evm.as_evm() {
 * // Use with alloy...
 * }
 * ```
 */
export type WalletAddress = string;

/**
 * Wrapped wallet balance response for OpenAPI
 */
export type WalletBalanceDataResponse = {
    data: WalletBalanceResponse;
};

export type WalletBalanceKind = 'funded' | 'promotional';

/**
 * Wallet balance response (funded + promotional)
 */
export type WalletBalanceResponse = {
    /**
     * Total wallet balance in atomic units
     */
    balance_atomic: number;
    balance_usd: string;
    /**
     * Breakdown by source
     */
    by_source: Array<WalletSourceBalance>;
    /**
     * Total funded balance (fiat purchases + tier bonuses)
     */
    funded_balance_atomic: number;
    funded_balance_usd: string;
    /**
     * Total promotional balance (bonuses, daily claims, referrals, admin grants)
     */
    promotional_balance_atomic: number;
    promotional_balance_usd: string;
    /**
     * Total lifetime SerenBucks purchases in cents (for plan upgrade tracking)
     */
    total_purchases_cents: number;
    total_purchases_usd: string;
    wallet_address: string;
};

/**
 * Balance by source type
 */
export type WalletSourceBalance = {
    balance_atomic: number;
    balance_usd: string;
    kind: WalletBalanceKind;
    source: AgentCreditSource;
};

/**
 * Wrapped transaction history response for OpenAPI
 */
export type WalletTransactionHistoryDataResponse = {
    data: WalletTransactionHistoryResponse;
};

/**
 * Response for transaction history
 */
export type WalletTransactionHistoryResponse = {
    limit: number;
    offset: number;
    total: number;
    transactions: Array<WalletTransactionResponse>;
};

/**
 * Response for a single transaction
 */
export type WalletTransactionResponse = {
    amount_atomic: number;
    amount_usd: string;
    /**
     * Bonus amount included in this grant (only for tier_bonus source)
     */
    bonus_amount_usd?: string | null;
    created_at: string;
    description?: string | null;
    expires_at?: string | null;
    id: string;
    /**
     * Original Stripe payment amount (only for fiat_purchase source)
     */
    paid_amount_usd?: string | null;
    remaining_atomic: number;
    remaining_usd: string;
    source: string;
};

/**
 * Webhook created response (includes secret on creation only)
 */
export type WebhookCreated = {
    /**
     * The webhook secret - only shown once at creation time
     */
    secret: string;
    webhook: WebhookInfo;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type WebhookCreatedResponse = {
    data: WebhookCreated;
    pagination?: PaginationMeta | null;
};

/**
 * Webhook delivery record
 */
export type WebhookDelivery = {
    attempt_number: number;
    created_at: string;
    delivered_at?: string | null;
    error_message?: string | null;
    event_id: string;
    event_type: string;
    id: string;
    next_retry_at?: string | null;
    payload: {
        [key: string]: unknown;
    };
    response_body?: string | null;
    response_status?: number | null;
    webhook_id: string;
};

/**
 * Webhook response (hides secret)
 */
export type WebhookInfo = {
    created_at: string;
    created_by: string;
    enabled: boolean;
    events: Array<string>;
    id: string;
    name: string;
    organization_id: string;
    project_id?: string | null;
    url: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type WebhookInfoResponse = {
    data: WebhookInfo;
    pagination?: PaginationMeta | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type WebhooksResponse = {
    /**
     * The actual response data (can be a single object or a collection)
     */
    data: Array<WebhookInfo>;
    pagination?: PaginationMeta | null;
};

export type ExecuteApiData = {
    body: ApiRequestBody;
    path?: never;
    query?: never;
    url: '/agent/api';
};

export type ExecuteApiErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Payment required
     */
    402: PaymentRequiredResponseWithInfo;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ExecuteApiError = ExecuteApiErrors[keyof ExecuteApiErrors];

export type ExecuteApiResponses = {
    /**
     * API request executed successfully
     */
    200: ApiResultResponse;
};

export type ExecuteApiResponse = ExecuteApiResponses[keyof ExecuteApiResponses];

export type ExecuteQueryData = {
    body: QueryRequestBody;
    path?: never;
    query?: never;
    url: '/agent/database';
};

export type ExecuteQueryErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Payment required
     */
    402: PaymentRequiredResponseWithInfo;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ExecuteQueryError = ExecuteQueryErrors[keyof ExecuteQueryErrors];

export type ExecuteQueryResponses = {
    /**
     * Query executed successfully
     */
    200: QueryResultResponse;
};

export type ExecuteQueryResponse = ExecuteQueryResponses[keyof ExecuteQueryResponses];

export type OnchainDepositData = {
    body: OnchainDepositRequest;
    path?: never;
    query?: never;
    url: '/agent/deposit';
};

export type OnchainDepositErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Payment required
     */
    402: PaymentRequiredResponseWithInfo;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type OnchainDepositError = OnchainDepositErrors[keyof OnchainDepositErrors];

export type OnchainDepositResponses = {
    /**
     * Deposit successful
     */
    200: OnchainDepositResponse;
};

export type OnchainDepositResponse2 = OnchainDepositResponses[keyof OnchainDepositResponses];

export type EstimateQueryData = {
    body: EstimateRequestBody;
    path?: never;
    query?: never;
    url: '/agent/estimate';
};

export type EstimateQueryErrors = {
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type EstimateQueryResponses = {
    /**
     * Cost estimate
     */
    200: EstimateResponse;
};

export type EstimateQueryResponse = EstimateQueryResponses[keyof EstimateQueryResponses];

export type CallMcpToolData = {
    body: CallMcpToolRequest;
    path?: never;
    query?: never;
    url: '/agent/mcp/call';
};

export type CallMcpToolErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * OAuth connection required for BYOC publisher
     */
    403: unknown;
    /**
     * Publisher or tool not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CallMcpToolResponses = {
    /**
     * Tool called successfully
     */
    200: McpToolCallResponse;
};

export type CallMcpToolResponse = CallMcpToolResponses[keyof CallMcpToolResponses];

export type DiscoverMcpCapabilitiesData = {
    body: DiscoverMcpCapabilitiesRequest;
    path?: never;
    query?: never;
    url: '/agent/mcp/capabilities';
};

export type DiscoverMcpCapabilitiesErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * OAuth connection required for BYOC publisher
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DiscoverMcpCapabilitiesResponses = {
    /**
     * Capabilities discovered successfully
     */
    200: McpCapabilitiesResponse;
};

export type DiscoverMcpCapabilitiesResponse = DiscoverMcpCapabilitiesResponses[keyof DiscoverMcpCapabilitiesResponses];

export type ReadMcpResourceData = {
    body: ReadMcpResourceRequest;
    path?: never;
    query?: never;
    url: '/agent/mcp/resource';
};

export type ReadMcpResourceErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * OAuth connection required for BYOC publisher
     */
    403: unknown;
    /**
     * Publisher or resource not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ReadMcpResourceResponses = {
    /**
     * Resource read successfully
     */
    200: McpResourceReadResponse;
};

export type ReadMcpResourceResponse = ReadMcpResourceResponses[keyof ReadMcpResourceResponses];

export type ListMcpResourcesData = {
    body: ListMcpResourcesRequest;
    path?: never;
    query?: never;
    url: '/agent/mcp/resources';
};

export type ListMcpResourcesErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * OAuth connection required for BYOC publisher
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListMcpResourcesResponses = {
    /**
     * Resources listed successfully
     */
    200: McpResourcesResponse;
};

export type ListMcpResourcesResponse = ListMcpResourcesResponses[keyof ListMcpResourcesResponses];

export type ListMcpToolsData = {
    body: ListMcpToolsRequest;
    path?: never;
    query?: never;
    url: '/agent/mcp/tools';
};

export type ListMcpToolsErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * OAuth connection required for BYOC publisher
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListMcpToolsResponses = {
    /**
     * Tools listed successfully
     */
    200: McpToolsResponse;
};

export type ListMcpToolsResponse = ListMcpToolsResponses[keyof ListMcpToolsResponses];

export type ListStorePublishersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by verification status
         */
        is_verified?: boolean | null;
        /**
         * Search by name or slug
         */
        search?: string | null;
        /**
         * Maximum number of results (default: 50, max: 100)
         */
        limit?: number;
        /**
         * Offset for pagination
         */
        offset?: number;
    };
    url: '/agent/publishers';
};

export type ListStorePublishersErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListStorePublishersResponses = {
    /**
     * Publishers retrieved successfully
     */
    200: PaginatedPublishersResponse;
};

export type ListStorePublishersResponse = ListStorePublishersResponses[keyof ListStorePublishersResponses];

export type CreatePublisherApiKeyData = {
    body: CreatePublisherRequest;
    path?: never;
    query?: never;
    url: '/agent/publishers';
};

export type CreatePublisherApiKeyErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * API key required
     */
    401: unknown;
    /**
     * Publisher slug already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreatePublisherApiKeyResponses = {
    /**
     * Publisher created successfully
     */
    201: PublisherDataResponse;
};

export type CreatePublisherApiKeyResponse = CreatePublisherApiKeyResponses[keyof CreatePublisherApiKeyResponses];

export type SuggestPublishersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The task or query to match against publisher capabilities.
         * Examples: "scrape website", "AI research", "PDF extraction"
         */
        query: string;
        /**
         * Type of suggestions: "publisher", "agent", or "both" (default: "both")
         * Note: Agent suggestions are planned but not yet implemented.
         */
        type?: string;
        /**
         * Maximum number of results (default: 5, max: 20)
         */
        limit?: number;
    };
    url: '/agent/publishers/suggest';
};

export type SuggestPublishersErrors = {
    /**
     * Invalid query parameters
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type SuggestPublishersResponses = {
    /**
     * Publisher suggestions retrieved successfully
     */
    200: SuggestDataResponse;
};

export type SuggestPublishersResponse = SuggestPublishersResponses[keyof SuggestPublishersResponses];

export type GetStorePublisherData = {
    body?: never;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
    };
    query?: never;
    url: '/agent/publishers/{slug}';
};

export type GetStorePublisherErrors = {
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetStorePublisherResponses = {
    /**
     * Publisher retrieved successfully
     */
    200: PublisherDataResponse;
};

export type GetStorePublisherResponse = GetStorePublisherResponses[keyof GetStorePublisherResponses];

export type UpdatePublisherApiKeyData = {
    body: UpdatePublisherRequest;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
    };
    query?: never;
    url: '/agent/publishers/{slug}';
};

export type UpdatePublisherApiKeyErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Not authorized to update this publisher
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdatePublisherApiKeyResponses = {
    /**
     * Publisher updated successfully
     */
    200: PublisherDataResponse;
};

export type UpdatePublisherApiKeyResponse = UpdatePublisherApiKeyResponses[keyof UpdatePublisherApiKeyResponses];

export type UploadPublisherLogoApiKeyData = {
    body: LogoUploadRequest;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
    };
    query?: never;
    url: '/agent/publishers/{slug}/logo';
};

export type UploadPublisherLogoApiKeyErrors = {
    /**
     * Invalid image format or size
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Not authorized to update this publisher
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UploadPublisherLogoApiKeyResponses = {
    /**
     * Logo uploaded successfully
     */
    200: LogoUploadDataResponse;
};

export type UploadPublisherLogoApiKeyResponse = UploadPublisherLogoApiKeyResponses[keyof UploadPublisherLogoApiKeyResponses];

export type ExecuteApiStreamData = {
    body: ApiRequestBody;
    path?: never;
    query?: never;
    url: '/agent/stream';
};

export type ExecuteApiStreamErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Payment required
     */
    402: PaymentRequiredResponseWithInfo;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ExecuteApiStreamError = ExecuteApiStreamErrors[keyof ExecuteApiStreamErrors];

export type ExecuteApiStreamResponses = {
    /**
     * API response streamed successfully
     */
    200: string;
};

export type ExecuteApiStreamResponse = ExecuteApiStreamResponses[keyof ExecuteApiStreamResponses];

export type GetSupportedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agent/supported';
};

export type GetSupportedErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetSupportedResponses = {
    /**
     * Supported payment kinds
     */
    200: SupportedResponse;
};

export type GetSupportedResponse = GetSupportedResponses[keyof GetSupportedResponses];

export type ListTemplatesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter to verified templates only
         */
        verified_only?: boolean | null;
        /**
         * Filter by language (python, typescript, rust)
         */
        language?: string | null;
        /**
         * Minimum price in atomic units
         */
        min_price?: number | null;
        /**
         * Maximum price in atomic units
         */
        max_price?: number | null;
        /**
         * Search in name and description
         */
        search?: string | null;
        /**
         * Sort order (popularity, price_asc, price_desc, newest, oldest)
         */
        sort_by?: TemplateSortBy | null;
        /**
         * Maximum number of templates to return (default: 50)
         */
        limit?: number | null;
        /**
         * Offset for pagination (default: 0)
         */
        offset?: number | null;
    };
    url: '/agent/templates';
};

export type ListTemplatesErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListTemplatesResponses = {
    /**
     * Templates retrieved successfully
     */
    200: TemplateListResponse;
};

export type ListTemplatesResponse = ListTemplatesResponses[keyof ListTemplatesResponses];

export type PublishTemplateData = {
    body: CreateTemplateRequest;
    path?: never;
    query?: never;
    url: '/agent/templates/publish';
};

export type PublishTemplateErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Template slug already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type PublishTemplateResponses = {
    /**
     * Template published successfully
     */
    201: TemplateDataResponse;
};

export type PublishTemplateResponse = PublishTemplateResponses[keyof PublishTemplateResponses];

export type GetTemplateData = {
    body?: never;
    path: {
        /**
         * Template slug
         */
        slug: string;
    };
    query?: never;
    url: '/agent/templates/{slug}';
};

export type GetTemplateErrors = {
    /**
     * Template not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetTemplateResponses = {
    /**
     * Template retrieved successfully
     */
    200: TemplateDataResponse;
};

export type GetTemplateResponse = GetTemplateResponses[keyof GetTemplateResponses];

export type InvokeTemplateData = {
    body: InvokeTemplateRequest;
    path: {
        /**
         * Template slug
         */
        slug: string;
    };
    query?: never;
    url: '/agent/templates/{slug}/invoke';
};

export type InvokeTemplateErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Authentication failed
     */
    401: unknown;
    /**
     * Payment required
     */
    402: unknown;
    /**
     * Template not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
    /**
     * Sandbox execution failed
     */
    503: unknown;
};

export type InvokeTemplateResponses = {
    /**
     * Template invoked successfully
     */
    200: InvokeDataResponse;
};

export type InvokeTemplateResponse2 = InvokeTemplateResponses[keyof InvokeTemplateResponses];

export type GetWalletBalanceData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agent/wallet/balance';
};

export type GetWalletBalanceErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetWalletBalanceResponses = {
    /**
     * Wallet balance retrieved
     */
    200: WalletBalanceDataResponse;
};

export type GetWalletBalanceResponse = GetWalletBalanceResponses[keyof GetWalletBalanceResponses];

export type ClaimPaymentMethodBonusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agent/wallet/bonus/payment-method';
};

export type ClaimPaymentMethodBonusErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Bonus already claimed
     */
    409: unknown;
};

export type ClaimPaymentMethodBonusResponses = {
    /**
     * Payment method bonus claimed
     */
    200: BonusClaimDataResponse;
};

export type ClaimPaymentMethodBonusResponse = ClaimPaymentMethodBonusResponses[keyof ClaimPaymentMethodBonusResponses];

export type ClaimSignupBonusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agent/wallet/bonus/signup';
};

export type ClaimSignupBonusErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Bonus already claimed
     */
    409: unknown;
};

export type ClaimSignupBonusResponses = {
    /**
     * Signup bonus claimed
     */
    200: BonusClaimDataResponse;
};

export type ClaimSignupBonusResponse = ClaimSignupBonusResponses[keyof ClaimSignupBonusResponses];

export type ClaimDailyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agent/wallet/daily/claim';
};

export type ClaimDailyErrors = {
    /**
     * Not eligible for daily claim
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ClaimDailyResponses = {
    /**
     * Daily credits claimed
     */
    200: DailyClaimDataResponse;
};

export type ClaimDailyResponse = ClaimDailyResponses[keyof ClaimDailyResponses];

export type CheckDailyEligibilityData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agent/wallet/daily/eligibility';
};

export type CheckDailyEligibilityErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CheckDailyEligibilityResponses = {
    /**
     * Eligibility checked
     */
    200: DailyClaimEligibilityDataResponse;
};

export type CheckDailyEligibilityResponse = CheckDailyEligibilityResponses[keyof CheckDailyEligibilityResponses];

export type CreateDepositData = {
    body: DepositRequest;
    path?: never;
    query?: never;
    url: '/agent/wallet/deposit';
};

export type CreateDepositErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CreateDepositResponses = {
    /**
     * Deposit initiated
     */
    200: DepositDataResponse;
};

export type CreateDepositResponse = CreateDepositResponses[keyof CreateDepositResponses];

export type GetReferralInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agent/wallet/referral';
};

export type GetReferralInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetReferralInfoResponses = {
    /**
     * Referral info retrieved
     */
    200: ReferralInfoDataResponse;
};

export type GetReferralInfoResponse = GetReferralInfoResponses[keyof GetReferralInfoResponses];

export type ApplyReferralCodeData = {
    body: ApplyReferralRequest;
    path?: never;
    query?: never;
    url: '/agent/wallet/referral/apply';
};

export type ApplyReferralCodeErrors = {
    /**
     * Invalid referral code
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Already has a referrer
     */
    409: unknown;
};

export type ApplyReferralCodeResponses = {
    /**
     * Referral code applied
     */
    200: unknown;
};

export type GetTransactionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Maximum number of transactions to return (default 50, max 100)
         */
        limit?: number;
        /**
         * Offset for pagination
         */
        offset?: number;
    };
    url: '/agent/wallet/transactions';
};

export type GetTransactionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetTransactionsResponses = {
    /**
     * Transaction history retrieved
     */
    200: WalletTransactionHistoryDataResponse;
};

export type GetTransactionsResponse = GetTransactionsResponses[keyof GetTransactionsResponses];

export type ForgotPasswordData = {
    body: ForgotPasswordRequest;
    path?: never;
    query?: never;
    url: '/auth/forgot-password';
};

export type ForgotPasswordErrors = {
    /**
     * Invalid request
     */
    400: unknown;
};

export type ForgotPasswordResponses = {
    /**
     * Password reset email sent if account exists
     */
    200: PasswordResetSentResponse;
};

export type ForgotPasswordResponse = ForgotPasswordResponses[keyof ForgotPasswordResponses];

export type GetCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/me';
};

export type GetCurrentUserErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetCurrentUserResponses = {
    /**
     * Current user information
     */
    200: UserInfoResponse;
};

export type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type ResendVerificationEmailData = {
    body: ResendVerificationRequest;
    path?: never;
    query?: never;
    url: '/auth/resend-verification';
};

export type ResendVerificationEmailErrors = {
    /**
     * Invalid request
     */
    400: unknown;
};

export type ResendVerificationEmailResponses = {
    /**
     * Verification email sent if account exists
     */
    200: VerificationSentResponse;
};

export type ResendVerificationEmailResponse = ResendVerificationEmailResponses[keyof ResendVerificationEmailResponses];

export type ResetPasswordData = {
    body: ResetPasswordRequest;
    path?: never;
    query?: never;
    url: '/auth/reset-password';
};

export type ResetPasswordErrors = {
    /**
     * Invalid or expired token
     */
    400: unknown;
    /**
     * Token not found
     */
    404: unknown;
};

export type ResetPasswordResponses = {
    /**
     * Password reset successfully
     */
    200: PasswordResetResponse;
};

export type ResetPasswordResponse = ResetPasswordResponses[keyof ResetPasswordResponses];

export type VerifyEmailData = {
    body: VerifyEmailRequest;
    path?: never;
    query?: never;
    url: '/auth/verify-email';
};

export type VerifyEmailErrors = {
    /**
     * Invalid or expired token
     */
    400: unknown;
};

export type VerifyEmailResponses = {
    /**
     * Email verified and user logged in
     */
    200: LoginResultResponse;
};

export type VerifyEmailResponse = VerifyEmailResponses[keyof VerifyEmailResponses];

export type GetBillingHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/billing/health';
};

export type GetBillingHealthErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetBillingHealthResponses = {
    /**
     * Billing health retrieved successfully
     */
    200: BillingHealthResponse;
};

export type GetBillingHealthResponse = GetBillingHealthResponses[keyof GetBillingHealthResponses];

export type GenerateInvoicesData = {
    body: GenerateInvoicesRequest;
    path?: never;
    query?: never;
    url: '/billing/invoices/generate';
};

export type GenerateInvoicesErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GenerateInvoicesResponses = {
    /**
     * Invoices generated successfully
     */
    200: InvoicesGeneratedResponse;
};

export type GenerateInvoicesResponse = GenerateInvoicesResponses[keyof GenerateInvoicesResponses];

export type GetInvoiceData = {
    body?: never;
    path: {
        /**
         * Invoice ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/invoices/{id}';
};

export type GetInvoiceErrors = {
    /**
     * Invoice not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetInvoiceResponses = {
    /**
     * Invoice retrieved successfully
     */
    200: InvoiceResponse;
};

export type GetInvoiceResponse = GetInvoiceResponses[keyof GetInvoiceResponses];

export type IssueInvoiceData = {
    body?: never;
    path: {
        /**
         * Invoice ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/invoices/{id}/issue';
};

export type IssueInvoiceErrors = {
    /**
     * Invoice not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type IssueInvoiceResponses = {
    /**
     * Invoice issued successfully
     */
    200: unknown;
};

export type CreatePaymentIntentData = {
    body?: never;
    path: {
        /**
         * Invoice ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/invoices/{id}/pay';
};

export type CreatePaymentIntentErrors = {
    /**
     * Invoice not in payable state
     */
    400: unknown;
    /**
     * Invoice not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreatePaymentIntentResponses = {
    /**
     * Payment intent created
     */
    200: PaymentIntentCreatedResponse;
};

export type CreatePaymentIntentResponse = CreatePaymentIntentResponses[keyof CreatePaymentIntentResponses];

export type GetPaymentHistoryData = {
    body?: never;
    path: {
        /**
         * Invoice ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/invoices/{id}/payments';
};

export type GetPaymentHistoryErrors = {
    /**
     * Invoice not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetPaymentHistoryResponses = {
    /**
     * Payment history retrieved
     */
    200: PaymentHistoryResponse;
};

export type GetPaymentHistoryResponse = GetPaymentHistoryResponses[keyof GetPaymentHistoryResponses];

export type ListPaymentMethodsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/billing/payment-methods';
};

export type ListPaymentMethodsErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListPaymentMethodsResponses = {
    /**
     * Payment methods retrieved
     */
    200: PaymentMethodsResponse;
};

export type ListPaymentMethodsResponse = ListPaymentMethodsResponses[keyof ListPaymentMethodsResponses];

export type AddPaymentMethodData = {
    body: AddPaymentMethodRequest;
    path?: never;
    query?: never;
    url: '/billing/payment-methods';
};

export type AddPaymentMethodErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type AddPaymentMethodResponses = {
    /**
     * Payment method added
     */
    200: PaymentMethodAddedResponse;
};

export type AddPaymentMethodResponse = AddPaymentMethodResponses[keyof AddPaymentMethodResponses];

export type DeletePaymentMethodData = {
    body?: never;
    path: {
        /**
         * Payment method ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/payment-methods/{id}';
};

export type DeletePaymentMethodErrors = {
    /**
     * Payment method not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeletePaymentMethodResponses = {
    /**
     * Payment method removed
     */
    204: void;
};

export type DeletePaymentMethodResponse = DeletePaymentMethodResponses[keyof DeletePaymentMethodResponses];

export type GetUsageSummaryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: {
        start_date?: string | null;
        end_date?: string | null;
    };
    url: '/billing/usage/{organization_id}';
};

export type GetUsageSummaryErrors = {
    /**
     * Organization not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetUsageSummaryResponses = {
    /**
     * Usage summary retrieved
     */
    200: UsageSummariesResponse;
};

export type GetUsageSummaryResponse = GetUsageSummaryResponses[keyof GetUsageSummaryResponses];

export type ListAllDatabasesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/databases';
};

export type ListAllDatabasesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListAllDatabasesResponses = {
    /**
     * List of all databases with context
     */
    200: DatabasesWithContextResponse;
};

export type ListAllDatabasesResponse = ListAllDatabasesResponses[keyof ListAllDatabasesResponses];

export type ListConnectionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/oauth/connections';
};

export type ListConnectionsResponses = {
    /**
     * List of user's OAuth connections
     */
    200: ConnectionsResponse;
};

export type ListConnectionsResponse = ListConnectionsResponses[keyof ListConnectionsResponses];

export type RevokeConnectionByIdData = {
    body?: never;
    path: {
        /**
         * OAuth provider UUID to disconnect
         */
        provider_id: string;
    };
    query?: never;
    url: '/oauth/connections/providers/{provider_id}';
};

export type RevokeConnectionByIdErrors = {
    /**
     * Connection not found
     */
    404: unknown;
};

export type RevokeConnectionByIdResponses = {
    /**
     * Connection revoked successfully
     */
    200: RevokeResponse;
};

export type RevokeConnectionByIdResponse = RevokeConnectionByIdResponses[keyof RevokeConnectionByIdResponses];

export type RevokeConnectionData = {
    body?: never;
    path: {
        /**
         * OAuth provider slug to disconnect
         */
        provider: string;
    };
    query?: never;
    url: '/oauth/connections/{provider}';
};

export type RevokeConnectionErrors = {
    /**
     * Connection not found
     */
    404: unknown;
};

export type RevokeConnectionResponses = {
    /**
     * Connection revoked successfully
     */
    200: RevokeResponse;
};

export type RevokeConnectionResponse = RevokeConnectionResponses[keyof RevokeConnectionResponses];

export type ListProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/oauth/providers';
};

export type ListProvidersResponses = {
    /**
     * List of available OAuth providers
     */
    200: ProvidersResponse;
};

export type ListProvidersResponse = ListProvidersResponses[keyof ListProvidersResponses];

export type InitiateOauthByIdData = {
    body?: never;
    path: {
        /**
         * OAuth provider UUID
         */
        provider_id: string;
    };
    query?: {
        /**
         * Where to redirect after OAuth completes
         */
        redirect_uri?: string | null;
    };
    url: '/oauth/providers/{provider_id}/authorize';
};

export type InitiateOauthByIdErrors = {
    /**
     * Provider not found
     */
    404: unknown;
};

export type OauthCallbackByIdData = {
    body?: never;
    path: {
        /**
         * OAuth provider UUID
         */
        provider_id: string;
    };
    query: {
        /**
         * Authorization code from provider
         */
        code: string;
        /**
         * State parameter for CSRF verification
         */
        state: string;
    };
    url: '/oauth/providers/{provider_id}/callback';
};

export type OauthCallbackByIdErrors = {
    /**
     * Invalid callback parameters
     */
    400: unknown;
    /**
     * Provider not found
     */
    404: unknown;
};

export type InitiateOauthData = {
    body?: never;
    path: {
        /**
         * OAuth provider slug (e.g., 'neon')
         */
        provider: string;
    };
    query?: {
        /**
         * Where to redirect after OAuth completes
         */
        redirect_uri?: string | null;
    };
    url: '/oauth/{provider}/authorize';
};

export type InitiateOauthErrors = {
    /**
     * Provider not found
     */
    404: unknown;
};

export type OauthCallbackData = {
    body?: never;
    path: {
        /**
         * OAuth provider slug
         */
        provider: string;
    };
    query: {
        /**
         * Authorization code from provider
         */
        code: string;
        /**
         * State parameter for CSRF verification
         */
        state: string;
    };
    url: '/oauth/{provider}/callback';
};

export type OauthCallbackErrors = {
    /**
     * Invalid callback parameters
     */
    400: unknown;
};

export type ListOrganizationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/organizations';
};

export type ListOrganizationsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListOrganizationsResponses = {
    /**
     * List of organizations
     */
    200: OrganizationsResponse;
};

export type ListOrganizationsResponse = ListOrganizationsResponses[keyof ListOrganizationsResponses];

export type ListDefaultOrgApiKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/organizations/default/api-keys';
};

export type ListDefaultOrgApiKeysErrors = {
    /**
     * User has no organization
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListDefaultOrgApiKeysResponses = {
    /**
     * List of API keys
     */
    200: ApiKeysResponse;
};

export type ListDefaultOrgApiKeysResponse = ListDefaultOrgApiKeysResponses[keyof ListDefaultOrgApiKeysResponses];

export type CreateDefaultOrgApiKeyData = {
    body: CreateApiKeyRequest;
    path?: never;
    query?: never;
    url: '/organizations/default/api-keys';
};

export type CreateDefaultOrgApiKeyErrors = {
    /**
     * User has no organization
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CreateDefaultOrgApiKeyResponses = {
    /**
     * API key created
     */
    201: ApiKeyCreatedResponse;
};

export type CreateDefaultOrgApiKeyResponse = CreateDefaultOrgApiKeyResponses[keyof CreateDefaultOrgApiKeyResponses];

export type RevokeDefaultOrgApiKeyData = {
    body?: never;
    path: {
        /**
         * API key ID
         */
        key_id: string;
    };
    query?: never;
    url: '/organizations/default/api-keys/{key_id}';
};

export type RevokeDefaultOrgApiKeyErrors = {
    /**
     * User has no organization
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * API key not found
     */
    404: unknown;
};

export type RevokeDefaultOrgApiKeyResponses = {
    /**
     * API key revoked
     */
    200: unknown;
};

export type GetPublisherTemplateAnalyticsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/agent/templates/analytics/{publisher_id}';
};

export type GetPublisherTemplateAnalyticsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetPublisherTemplateAnalyticsResponses = {
    /**
     * Analytics retrieved successfully
     */
    200: PublisherAnalyticsResponse;
};

export type GetPublisherTemplateAnalyticsResponse = GetPublisherTemplateAnalyticsResponses[keyof GetPublisherTemplateAnalyticsResponses];

export type ListOrgApiKeysData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/api-keys';
};

export type ListOrgApiKeysErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListOrgApiKeysResponses = {
    /**
     * List of API keys
     */
    200: ApiKeysResponse;
};

export type ListOrgApiKeysResponse = ListOrgApiKeysResponses[keyof ListOrgApiKeysResponses];

export type CreateOrgApiKeyData = {
    body: CreateApiKeyRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/api-keys';
};

export type CreateOrgApiKeyErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type CreateOrgApiKeyResponses = {
    /**
     * API key created
     */
    201: ApiKeyCreatedResponse;
};

export type CreateOrgApiKeyResponse = CreateOrgApiKeyResponses[keyof CreateOrgApiKeyResponses];

export type RevokeOrgApiKeyData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * API key ID
         */
        key_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/api-keys/{key_id}';
};

export type RevokeOrgApiKeyErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * API key not found
     */
    404: unknown;
};

export type RevokeOrgApiKeyResponses = {
    /**
     * API key revoked
     */
    200: unknown;
};

export type ListAuditLogsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: {
        /**
         * Filter by actor ID
         */
        actor_id?: string | null;
        /**
         * Filter by action (e.g., "project.create")
         */
        action?: string | null;
        /**
         * Filter by resource type (e.g., "project", "branch")
         */
        resource_type?: string | null;
        /**
         * Filter by resource ID
         */
        resource_id?: string | null;
        /**
         * Filter by status
         */
        status?: string | null;
        /**
         * Filter by action category
         */
        action_category?: string | null;
        /**
         * Filter by start date (ISO 8601)
         */
        start_date?: string | null;
        /**
         * Filter by end date (ISO 8601)
         */
        end_date?: string | null;
        /**
         * Maximum number of results (default 50, max 100)
         */
        limit?: number;
        /**
         * Offset for pagination
         */
        offset?: number;
    };
    url: '/organizations/{organization_id}/audit-logs';
};

export type ListAuditLogsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListAuditLogsResponses = {
    /**
     * Audit logs retrieved successfully
     */
    200: AuditLogListResponse;
};

export type ListAuditLogsResponse = ListAuditLogsResponses[keyof ListAuditLogsResponses];

export type GetAuditLogData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Audit log ID
         */
        log_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/audit-logs/{log_id}';
};

export type GetAuditLogErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Audit log not found
     */
    404: unknown;
};

export type GetAuditLogResponses = {
    /**
     * Audit log retrieved successfully
     */
    200: AuditLogResponse;
};

export type GetAuditLogResponse = GetAuditLogResponses[keyof GetAuditLogResponses];

export type GetEndpointBillingEventsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/billing/endpoints/{endpoint_id}/events';
};

export type GetEndpointBillingEventsErrors = {
    /**
     * Endpoint not found for organization
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetEndpointBillingEventsResponses = {
    /**
     * Billing events retrieved successfully
     */
    200: EndpointBillingEventsResponse;
};

export type GetEndpointBillingEventsResponse = GetEndpointBillingEventsResponses[keyof GetEndpointBillingEventsResponses];

export type GetOrganizationConsumptionData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: {
        /**
         * Optional ISO-8601 start date (YYYY-MM-DD), defaults to first day of current month.
         */
        start_date?: string | null;
        /**
         * Optional ISO-8601 end date (YYYY-MM-DD), defaults to today (UTC).
         */
        end_date?: string | null;
    };
    url: '/organizations/{organization_id}/consumption';
};

export type GetOrganizationConsumptionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User is not a member of the organization
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrganizationConsumptionResponses = {
    /**
     * Organization consumption retrieved
     */
    200: OrganizationConsumptionResponse;
};

export type GetOrganizationConsumptionResponse = GetOrganizationConsumptionResponses[keyof GetOrganizationConsumptionResponses];

export type ListInvitesData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/invites';
};

export type ListInvitesErrors = {
    /**
     * User is not allowed to view invites
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListInvitesResponses = {
    /**
     * Organization invites retrieved
     */
    200: OrganizationInvitesResponse;
};

export type ListInvitesResponse = ListInvitesResponses[keyof ListInvitesResponses];

export type CreateInviteData = {
    body: CreateOrganizationInviteRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/invites';
};

export type CreateInviteErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * User is not allowed to create invites
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateInviteResponses = {
    /**
     * Invite created and email sent
     */
    201: OrganizationInviteResponse;
};

export type CreateInviteResponse = CreateInviteResponses[keyof CreateInviteResponses];

export type ListMembersData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/members';
};

export type ListMembersErrors = {
    /**
     * User is not a member of the organization
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListMembersResponses = {
    /**
     * Organization members retrieved
     */
    200: OrganizationMembersResponse;
};

export type ListMembersResponse = ListMembersResponses[keyof ListMembersResponses];

export type AssignRoleData = {
    body: AssignRoleRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Member user ID
         */
        member_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/members/{member_id}/role';
};

export type AssignRoleErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - requires org.manage_members permission
     */
    403: unknown;
    /**
     * Member or role not found
     */
    404: unknown;
};

export type AssignRoleResponses = {
    /**
     * Role assigned successfully
     */
    200: unknown;
};

export type ListOrgOauthProvidersData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers';
};

export type ListOrgOauthProvidersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListOrgOauthProvidersResponses = {
    /**
     * List of OAuth providers
     */
    200: OAuthProvidersDataResponse;
};

export type ListOrgOauthProvidersResponse = ListOrgOauthProvidersResponses[keyof ListOrgOauthProvidersResponses];

export type CreateOrgOauthProviderData = {
    body: CreateOAuthProviderRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers';
};

export type CreateOrgOauthProviderErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Conflict - provider with this slug already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateOrgOauthProviderResponses = {
    /**
     * OAuth provider created
     */
    201: OAuthProviderDataResponse;
};

export type CreateOrgOauthProviderResponse = CreateOrgOauthProviderResponses[keyof CreateOrgOauthProviderResponses];

export type DeleteOrgOauthProviderData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * OAuth provider ID
         */
        provider_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers/{provider_id}';
};

export type DeleteOrgOauthProviderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Provider not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeleteOrgOauthProviderResponses = {
    /**
     * OAuth provider deleted
     */
    204: void;
};

export type DeleteOrgOauthProviderResponse = DeleteOrgOauthProviderResponses[keyof DeleteOrgOauthProviderResponses];

export type GetOrgOauthProviderData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * OAuth provider ID
         */
        provider_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers/{provider_id}';
};

export type GetOrgOauthProviderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Provider not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrgOauthProviderResponses = {
    /**
     * OAuth provider details
     */
    200: OAuthProviderDataResponse;
};

export type GetOrgOauthProviderResponse = GetOrgOauthProviderResponses[keyof GetOrgOauthProviderResponses];

export type UpdateOrgOauthProviderData = {
    body: UpdateOAuthProviderRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * OAuth provider ID
         */
        provider_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers/{provider_id}';
};

export type UpdateOrgOauthProviderErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Provider not found
     */
    404: unknown;
    /**
     * Conflict - provider with this slug already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdateOrgOauthProviderResponses = {
    /**
     * OAuth provider updated
     */
    200: OAuthProviderDataResponse;
};

export type UpdateOrgOauthProviderResponse = UpdateOrgOauthProviderResponses[keyof UpdateOrgOauthProviderResponses];

export type CheckPermissionData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Permission name to check
         */
        permission: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/permissions/check/{permission}';
};

export type CheckPermissionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type CheckPermissionResponses = {
    /**
     * Permission check result
     */
    200: boolean;
};

export type CheckPermissionResponse = CheckPermissionResponses[keyof CheckPermissionResponses];

export type GetMyPermissionsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/permissions/mine';
};

export type GetMyPermissionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type GetMyPermissionsResponses = {
    /**
     * User's permissions
     */
    200: Array<string>;
};

export type GetMyPermissionsResponse = GetMyPermissionsResponses[keyof GetMyPermissionsResponses];

export type GetOrganizationPlanData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/plan';
};

export type GetOrganizationPlanErrors = {
    /**
     * Organization or plan not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrganizationPlanResponses = {
    /**
     * Organization plan retrieved successfully
     */
    200: OrganizationPlanResponse;
};

export type GetOrganizationPlanResponse = GetOrganizationPlanResponses[keyof GetOrganizationPlanResponses];

export type ChangeOrganizationPlanData = {
    body: ChangePlanRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/plan';
};

export type ChangeOrganizationPlanErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Organization or plan not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ChangeOrganizationPlanResponses = {
    /**
     * Plan changed successfully
     */
    200: OrganizationPlanResponse;
};

export type ChangeOrganizationPlanResponse = ChangeOrganizationPlanResponses[keyof ChangeOrganizationPlanResponses];

export type ListOrgPublishersData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers';
};

export type ListOrgPublishersErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListOrgPublishersResponses = {
    /**
     * Publishers retrieved successfully
     */
    200: PublishersDataResponse;
};

export type ListOrgPublishersResponse = ListOrgPublishersResponses[keyof ListOrgPublishersResponses];

export type CreatePublisherData = {
    body: CreatePublisherRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers';
};

export type CreatePublisherErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher slug already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreatePublisherResponses = {
    /**
     * Publisher created successfully
     */
    201: PublisherDataResponse;
};

export type CreatePublisherResponse = CreatePublisherResponses[keyof CreatePublisherResponses];

export type DeletePublisherData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}';
};

export type DeletePublisherErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeletePublisherResponses = {
    /**
     * Publisher deleted successfully
     */
    200: unknown;
};

export type GetOrgPublisherData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}';
};

export type GetOrgPublisherErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrgPublisherResponses = {
    /**
     * Publisher retrieved successfully
     */
    200: PublisherDataResponse;
};

export type GetOrgPublisherResponse = GetOrgPublisherResponses[keyof GetOrgPublisherResponses];

export type UpdatePublisherData = {
    body: UpdatePublisherRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}';
};

export type UpdatePublisherErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdatePublisherResponses = {
    /**
     * Publisher updated successfully
     */
    200: PublisherDataResponse;
};

export type UpdatePublisherResponse = UpdatePublisherResponses[keyof UpdatePublisherResponses];

export type GetRevenueMetricsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: {
        /**
         * Number of days to analyze (default: 30)
         */
        days?: number;
    };
    url: '/organizations/{organization_id}/publishers/{publisher_id}/analytics/revenue';
};

export type GetRevenueMetricsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
};

export type GetRevenueMetricsResponses = {
    /**
     * Revenue metrics
     */
    200: RevenueMetrics;
};

export type GetRevenueMetricsResponse = GetRevenueMetricsResponses[keyof GetRevenueMetricsResponses];

export type GetRevenueByDayData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: {
        /**
         * Number of days to analyze (default: 30)
         */
        days?: number;
    };
    url: '/organizations/{organization_id}/publishers/{publisher_id}/analytics/revenue-by-day';
};

export type GetRevenueByDayErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
};

export type GetRevenueByDayResponses = {
    /**
     * Daily revenue breakdown
     */
    200: Array<RevenueByDay>;
};

export type GetRevenueByDayResponse = GetRevenueByDayResponses[keyof GetRevenueByDayResponses];

export type GetTopAgentsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: {
        /**
         * Number of agents to return (default: 10)
         */
        limit?: number;
    };
    url: '/organizations/{organization_id}/publishers/{publisher_id}/analytics/top-agents';
};

export type GetTopAgentsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
};

export type GetTopAgentsResponses = {
    /**
     * Top agents by spending
     */
    200: Array<TopAgent>;
};

export type GetTopAgentsResponse = GetTopAgentsResponses[keyof GetTopAgentsResponses];

export type GetOrgPublisherEarningsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}/earnings';
};

export type GetOrgPublisherEarningsErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrgPublisherEarningsResponses = {
    /**
     * Earnings retrieved successfully
     */
    200: PublisherEarningsDataResponse;
};

export type GetOrgPublisherEarningsResponse = GetOrgPublisherEarningsResponses[keyof GetOrgPublisherEarningsResponses];

export type ListOrgPublisherPayoutsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: {
        /**
         * Maximum number of results (default: 50)
         */
        limit?: number | null;
        /**
         * Offset for pagination
         */
        offset?: number | null;
    };
    url: '/organizations/{organization_id}/publishers/{publisher_id}/payouts';
};

export type ListOrgPublisherPayoutsErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListOrgPublisherPayoutsResponses = {
    /**
     * Payouts retrieved successfully
     */
    200: PublisherPayoutsDataResponse;
};

export type ListOrgPublisherPayoutsResponse = ListOrgPublisherPayoutsResponses[keyof ListOrgPublisherPayoutsResponses];

export type CreateOrgPublisherPayoutData = {
    body: CreatePublisherPayoutRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}/payouts';
};

export type CreateOrgPublisherPayoutErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateOrgPublisherPayoutResponses = {
    /**
     * Payout request created
     */
    201: PublisherPayoutDataResponse;
};

export type CreateOrgPublisherPayoutResponse = CreateOrgPublisherPayoutResponses[keyof CreateOrgPublisherPayoutResponses];

export type UpdatePublisherPricingData = {
    body: UpdatePricingRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}/pricing';
};

export type UpdatePublisherPricingErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdatePublisherPricingResponses = {
    /**
     * Pricing updated successfully
     */
    200: PricingConfigDataResponse;
};

export type UpdatePublisherPricingResponse = UpdatePublisherPricingResponses[keyof UpdatePublisherPricingResponses];

export type GetQuotaUsageData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/quota';
};

export type GetQuotaUsageErrors = {
    /**
     * Organization or plan not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetQuotaUsageResponses = {
    /**
     * Quota usage retrieved successfully
     */
    200: QuotaUsageResponse;
};

export type GetQuotaUsageResponse = GetQuotaUsageResponses[keyof GetQuotaUsageResponses];

export type ListOrganizationRolesData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles';
};

export type ListOrganizationRolesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type ListOrganizationRolesResponses = {
    /**
     * Roles retrieved successfully
     */
    200: RbacRolesResponse;
};

export type ListOrganizationRolesResponse = ListOrganizationRolesResponses[keyof ListOrganizationRolesResponses];

export type CreateOrganizationRoleData = {
    body: CreateRoleRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles';
};

export type CreateOrganizationRoleErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - requires org.manage_roles permission
     */
    403: unknown;
};

export type CreateOrganizationRoleResponses = {
    /**
     * Role created successfully
     */
    201: RbacRoleResponse;
};

export type CreateOrganizationRoleResponse = CreateOrganizationRoleResponses[keyof CreateOrganizationRoleResponses];

export type DeleteOrganizationRoleData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Role ID
         */
        role_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles/{role_id}';
};

export type DeleteOrganizationRoleErrors = {
    /**
     * Cannot delete built-in role
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - requires org.manage_roles permission
     */
    403: unknown;
    /**
     * Role not found
     */
    404: unknown;
};

export type DeleteOrganizationRoleResponses = {
    /**
     * Role deleted successfully
     */
    204: void;
};

export type DeleteOrganizationRoleResponse = DeleteOrganizationRoleResponses[keyof DeleteOrganizationRoleResponses];

export type GetRoleData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Role ID
         */
        role_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles/{role_id}';
};

export type GetRoleErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Role not found
     */
    404: unknown;
};

export type GetRoleResponses = {
    /**
     * Role retrieved successfully
     */
    200: RbacRoleResponse;
};

export type GetRoleResponse = GetRoleResponses[keyof GetRoleResponses];

export type UpdateRoleData = {
    body: UpdateRoleRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Role ID
         */
        role_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles/{role_id}';
};

export type UpdateRoleErrors = {
    /**
     * Invalid request or cannot modify built-in role
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - requires org.manage_roles permission
     */
    403: unknown;
    /**
     * Role not found
     */
    404: unknown;
};

export type UpdateRoleResponses = {
    /**
     * Role updated successfully
     */
    200: RbacRoleResponse;
};

export type UpdateRoleResponse = UpdateRoleResponses[keyof UpdateRoleResponses];

export type ListOrgVpcEndpointsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: {
        /**
         * Filter endpoints by region
         */
        region?: string | null;
    };
    url: '/organizations/{organization_id}/vpc-endpoints';
};

export type ListOrgVpcEndpointsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListOrgVpcEndpointsResponses = {
    /**
     * List of VPC endpoints
     */
    200: Array<OrganizationVpcEndpoint>;
};

export type ListOrgVpcEndpointsResponse = ListOrgVpcEndpointsResponses[keyof ListOrgVpcEndpointsResponses];

export type CreateOrgVpcEndpointData = {
    body: CreateOrganizationVpcEndpointRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc-endpoints';
};

export type CreateOrgVpcEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CreateOrgVpcEndpointResponses = {
    /**
     * VPC endpoint recorded
     */
    201: OrganizationVpcEndpointResponse;
};

export type CreateOrgVpcEndpointResponse = CreateOrgVpcEndpointResponses[keyof CreateOrgVpcEndpointResponses];

export type DeleteOrgVpcEndpointData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Organization VPC endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc-endpoints/{endpoint_id}';
};

export type DeleteOrgVpcEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * VPC endpoint not found
     */
    404: unknown;
};

export type DeleteOrgVpcEndpointResponses = {
    /**
     * VPC endpoint removed
     */
    204: void;
};

export type DeleteOrgVpcEndpointResponse = DeleteOrgVpcEndpointResponses[keyof DeleteOrgVpcEndpointResponses];

export type GetOrgVpcEndpointData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Organization VPC endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc-endpoints/{endpoint_id}';
};

export type GetOrgVpcEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * VPC endpoint not found
     */
    404: unknown;
};

export type GetOrgVpcEndpointResponses = {
    /**
     * VPC endpoint details
     */
    200: OrganizationVpcEndpointResponse;
};

export type GetOrgVpcEndpointResponse = GetOrgVpcEndpointResponses[keyof GetOrgVpcEndpointResponses];

export type ListOrgVpcEndpointsByRegionData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Region
         */
        region_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc/region/{region_id}/vpc_endpoints';
};

export type ListOrgVpcEndpointsByRegionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListOrgVpcEndpointsByRegionResponses = {
    /**
     * List of VPC endpoints
     */
    200: Array<OrganizationVpcEndpoint>;
};

export type ListOrgVpcEndpointsByRegionResponse = ListOrgVpcEndpointsByRegionResponses[keyof ListOrgVpcEndpointsByRegionResponses];

export type DeleteOrgVpcEndpointByRegionData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Region
         */
        region_id: string;
        /**
         * Organization VPC endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc/region/{region_id}/vpc_endpoints/{endpoint_id}';
};

export type DeleteOrgVpcEndpointByRegionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * VPC endpoint not found
     */
    404: unknown;
};

export type DeleteOrgVpcEndpointByRegionResponses = {
    /**
     * VPC endpoint removed
     */
    204: void;
};

export type DeleteOrgVpcEndpointByRegionResponse = DeleteOrgVpcEndpointByRegionResponses[keyof DeleteOrgVpcEndpointByRegionResponses];

export type GetOrgVpcEndpointByRegionData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Region
         */
        region_id: string;
        /**
         * Organization VPC endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc/region/{region_id}/vpc_endpoints/{endpoint_id}';
};

export type GetOrgVpcEndpointByRegionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * VPC endpoint not found
     */
    404: unknown;
};

export type GetOrgVpcEndpointByRegionResponses = {
    /**
     * VPC endpoint details
     */
    200: OrganizationVpcEndpointResponse;
};

export type GetOrgVpcEndpointByRegionResponse = GetOrgVpcEndpointByRegionResponses[keyof GetOrgVpcEndpointByRegionResponses];

export type ListOrgVpcEndpointsAliasData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc/vpc_endpoints';
};

export type ListOrgVpcEndpointsAliasErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListOrgVpcEndpointsAliasResponses = {
    /**
     * List of VPC endpoints
     */
    200: Array<OrganizationVpcEndpoint>;
};

export type ListOrgVpcEndpointsAliasResponse = ListOrgVpcEndpointsAliasResponses[keyof ListOrgVpcEndpointsAliasResponses];

export type ListWebhooksData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks';
};

export type ListWebhooksErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type ListWebhooksResponses = {
    /**
     * Webhooks retrieved successfully
     */
    200: WebhooksResponse;
};

export type ListWebhooksResponse = ListWebhooksResponses[keyof ListWebhooksResponses];

export type CreateWebhookData = {
    body: CreateWebhookRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks';
};

export type CreateWebhookErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type CreateWebhookResponses = {
    /**
     * Webhook created successfully
     */
    201: WebhookCreatedResponse;
};

export type CreateWebhookResponse = CreateWebhookResponses[keyof CreateWebhookResponses];

export type DeleteWebhookData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}';
};

export type DeleteWebhookErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type DeleteWebhookResponses = {
    /**
     * Webhook deleted successfully
     */
    204: void;
};

export type DeleteWebhookResponse = DeleteWebhookResponses[keyof DeleteWebhookResponses];

export type GetWebhookData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}';
};

export type GetWebhookErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type GetWebhookResponses = {
    /**
     * Webhook retrieved successfully
     */
    200: WebhookInfoResponse;
};

export type GetWebhookResponse = GetWebhookResponses[keyof GetWebhookResponses];

export type UpdateWebhookData = {
    body: UpdateWebhookRequest;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}';
};

export type UpdateWebhookErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type UpdateWebhookResponses = {
    /**
     * Webhook updated successfully
     */
    200: WebhookInfoResponse;
};

export type UpdateWebhookResponse = UpdateWebhookResponses[keyof UpdateWebhookResponses];

export type ListWebhookDeliveriesData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}/deliveries';
};

export type ListWebhookDeliveriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type ListWebhookDeliveriesResponses = {
    /**
     * Deliveries retrieved successfully
     */
    200: Array<WebhookDelivery>;
};

export type ListWebhookDeliveriesResponse = ListWebhookDeliveriesResponses[keyof ListWebhookDeliveriesResponses];

export type RotateWebhookSecretData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}/rotate-secret';
};

export type RotateWebhookSecretErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type RotateWebhookSecretResponses = {
    /**
     * Secret rotated successfully
     */
    200: WebhookCreatedResponse;
};

export type RotateWebhookSecretResponse = RotateWebhookSecretResponses[keyof RotateWebhookSecretResponses];

export type ListPermissionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/permissions';
};

export type ListPermissionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListPermissionsResponses = {
    /**
     * Permissions retrieved successfully
     */
    200: Array<Permission>;
};

export type ListPermissionsResponse = ListPermissionsResponses[keyof ListPermissionsResponses];

export type ListPlansData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/plans';
};

export type ListPlansErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListPlansResponses = {
    /**
     * Plans retrieved successfully
     */
    200: PlansResponse;
};

export type ListPlansResponse = ListPlansResponses[keyof ListPlansResponses];

export type GetPlanData = {
    body?: never;
    path: {
        /**
         * Plan ID
         */
        plan_id: string;
    };
    query?: never;
    url: '/plans/{plan_id}';
};

export type GetPlanErrors = {
    /**
     * Plan not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetPlanResponses = {
    /**
     * Plan retrieved successfully
     */
    200: PlanResponse;
};

export type GetPlanResponse = GetPlanResponses[keyof GetPlanResponses];

export type ListProjectsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Maximum number of items to return (default: 20, max: 100)
         */
        limit?: number | null;
        /**
         * Number of items to skip (default: 0)
         */
        offset?: number | null;
    };
    url: '/projects';
};

export type ListProjectsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListProjectsResponses = {
    /**
     * List of projects
     */
    200: PaginatedProjectResponse;
};

export type ListProjectsResponse = ListProjectsResponses[keyof ListProjectsResponses];

export type CreateProjectData = {
    body: CreateProjectRequest;
    path?: never;
    query?: never;
    url: '/projects';
};

export type CreateProjectErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CreateProjectResponses = {
    /**
     * Project created successfully
     */
    201: ProjectCreatedResponse;
};

export type CreateProjectResponse = CreateProjectResponses[keyof CreateProjectResponses];

export type DeleteProjectData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}';
};

export type DeleteProjectErrors = {
    /**
     * Cannot delete project with existing branches
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type DeleteProjectResponses = {
    /**
     * Project deleted successfully
     */
    200: unknown;
};

export type GetProjectData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}';
};

export type GetProjectErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type GetProjectResponses = {
    /**
     * Project details
     */
    200: ProjectResponse;
};

export type GetProjectResponse = GetProjectResponses[keyof GetProjectResponses];

export type UpdateProjectData = {
    body: UpdateProjectRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}';
};

export type UpdateProjectErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type UpdateProjectResponses = {
    /**
     * Project updated successfully
     */
    200: ProjectResponse;
};

export type UpdateProjectResponse = UpdateProjectResponses[keyof UpdateProjectResponses];

export type ListBranchProtectionRulesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branch-protection';
};

export type ListBranchProtectionRulesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type ListBranchProtectionRulesResponses = {
    /**
     * List of branch protection rules
     */
    200: BranchProtectionsResponse;
};

export type ListBranchProtectionRulesResponse = ListBranchProtectionRulesResponses[keyof ListBranchProtectionRulesResponses];

export type ListBranchesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches';
};

export type ListBranchesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type ListBranchesResponses = {
    /**
     * List of branches
     */
    200: BranchesResponse;
};

export type ListBranchesResponse = ListBranchesResponses[keyof ListBranchesResponses];

export type CreateBranchData = {
    body: CreateBranchRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches';
};

export type CreateBranchErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type CreateBranchResponses = {
    /**
     * Branch created successfully
     */
    201: BranchCreationResultResponse;
};

export type CreateBranchResponse = CreateBranchResponses[keyof CreateBranchResponses];

export type GetBranchCountData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/count';
};

export type GetBranchCountErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type GetBranchCountResponses = {
    /**
     * Branch count retrieved successfully
     */
    200: unknown;
};

export type DeleteBranchData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}';
};

export type DeleteBranchErrors = {
    /**
     * Cannot delete branch with existing endpoints
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type DeleteBranchResponses = {
    /**
     * Branch deleted successfully
     */
    200: unknown;
};

export type GetBranchData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}';
};

export type GetBranchErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type GetBranchResponses = {
    /**
     * Branch details
     */
    200: BranchResponse;
};

export type GetBranchResponse = GetBranchResponses[keyof GetBranchResponses];

export type RenameBranchData = {
    body: RenameBranchRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}';
};

export type RenameBranchErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type RenameBranchResponses = {
    /**
     * Branch renamed successfully
     */
    200: BranchResponse;
};

export type RenameBranchResponse = RenameBranchResponses[keyof RenameBranchResponses];

export type SetBranchArchivedData = {
    body: SetBranchArchivedRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/archived';
};

export type SetBranchArchivedErrors = {
    /**
     * Cannot archive the default branch
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type SetBranchArchivedResponses = {
    /**
     * Branch archived status updated successfully
     */
    200: unknown;
};

export type GetConnectionStringData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: {
        /**
         * Return pooled connection (default: false)
         */
        pooled?: boolean | null;
        /**
         * PostgreSQL role/username to use (default: serendb_owner)
         */
        role?: string | null;
    };
    url: '/projects/{project_id}/branches/{branch_id}/connection-string';
};

export type GetConnectionStringErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch or endpoint not found
     */
    404: unknown;
};

export type GetConnectionStringResponses = {
    /**
     * Connection string retrieved
     */
    200: ConnectionStringResponse;
};

export type GetConnectionStringResponse = GetConnectionStringResponses[keyof GetConnectionStringResponses];

export type ListDatabasesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/databases';
};

export type ListDatabasesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type ListDatabasesResponses = {
    /**
     * List of databases
     */
    200: DatabasesWithOwnerResponse;
};

export type ListDatabasesResponse = ListDatabasesResponses[keyof ListDatabasesResponses];

export type CreateDatabaseData = {
    body: CreateDatabaseRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/databases';
};

export type CreateDatabaseErrors = {
    /**
     * Bad request - database already exists or invalid parameters
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type CreateDatabaseResponses = {
    /**
     * Database created successfully
     */
    201: DatabaseCreatedResponse;
};

export type CreateDatabaseResponse = CreateDatabaseResponses[keyof CreateDatabaseResponses];

export type DeleteDatabaseData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Database ID
         */
        database_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/databases/{database_id}';
};

export type DeleteDatabaseErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Database or branch not found
     */
    404: unknown;
};

export type DeleteDatabaseResponses = {
    /**
     * Database deleted successfully
     */
    200: unknown;
};

export type GetDatabaseData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Database ID
         */
        database_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/databases/{database_id}';
};

export type GetDatabaseErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Database or branch not found
     */
    404: unknown;
};

export type GetDatabaseResponses = {
    /**
     * Database details
     */
    200: DatabaseWithOwnerResponse;
};

export type GetDatabaseResponse = GetDatabaseResponses[keyof GetDatabaseResponses];

export type UpdateDatabaseData = {
    body: UpdateDatabaseRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Database ID
         */
        database_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/databases/{database_id}';
};

export type UpdateDatabaseErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Database or branch not found
     */
    404: unknown;
};

export type UpdateDatabaseResponses = {
    /**
     * Database updated successfully
     */
    200: DatabaseWithOwnerResponse;
};

export type UpdateDatabaseResponse = UpdateDatabaseResponses[keyof UpdateDatabaseResponses];

export type DeleteDatabaseByNameData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Database name
         */
        database_name: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/databases/{database_name}';
};

export type DeleteDatabaseByNameErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Database or branch not found
     */
    404: unknown;
};

export type DeleteDatabaseByNameResponses = {
    /**
     * Database deleted successfully
     */
    200: unknown;
};

export type GetDatabaseByNameData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Database name
         */
        database_name: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/databases/{database_name}';
};

export type GetDatabaseByNameErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Database or branch not found
     */
    404: unknown;
};

export type GetDatabaseByNameResponses = {
    /**
     * Database details
     */
    200: DatabaseWithOwnerResponse;
};

export type GetDatabaseByNameResponse = GetDatabaseByNameResponses[keyof GetDatabaseByNameResponses];

export type UpdateDatabaseByNameData = {
    body: UpdateDatabaseRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Database name
         */
        database_name: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/databases/{database_name}';
};

export type UpdateDatabaseByNameErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Database or branch not found
     */
    404: unknown;
};

export type UpdateDatabaseByNameResponses = {
    /**
     * Database updated successfully
     */
    200: DatabaseWithOwnerResponse;
};

export type UpdateDatabaseByNameResponse = UpdateDatabaseByNameResponses[keyof UpdateDatabaseByNameResponses];

export type GetBranchDetailsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/details';
};

export type GetBranchDetailsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type GetBranchDetailsResponses = {
    /**
     * Branch details retrieved successfully
     */
    200: BranchDetailResponse;
};

export type GetBranchDetailsResponse = GetBranchDetailsResponses[keyof GetBranchDetailsResponses];

export type ListEndpointsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/endpoints';
};

export type ListEndpointsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListEndpointsResponses = {
    /**
     * List of endpoints
     */
    200: EndpointsResponse;
};

export type ListEndpointsResponse = ListEndpointsResponses[keyof ListEndpointsResponses];

export type CreateEndpointData = {
    body: CreateEndpointRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/endpoints';
};

export type CreateEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project or branch not found
     */
    404: unknown;
};

export type CreateEndpointResponses = {
    /**
     * Endpoint created successfully
     */
    201: EndpointCreatedResponse;
};

export type CreateEndpointResponse = CreateEndpointResponses[keyof CreateEndpointResponses];

export type DeleteEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/endpoints/{endpoint_id}';
};

export type DeleteEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type DeleteEndpointResponses = {
    /**
     * Endpoint deleted successfully
     */
    200: unknown;
};

export type UpdateEndpointData = {
    body: UpdateEndpointRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/endpoints/{endpoint_id}';
};

export type UpdateEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type UpdateEndpointResponses = {
    /**
     * Endpoint updated successfully
     */
    200: EndpointResponse;
};

export type UpdateEndpointResponse = UpdateEndpointResponses[keyof UpdateEndpointResponses];

export type StartEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/endpoints/{endpoint_id}/start';
};

export type StartEndpointErrors = {
    /**
     * Endpoint already running
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type StartEndpointResponses = {
    /**
     * Endpoint start initiated
     */
    200: EndpointStatusInfoResponse;
};

export type StartEndpointResponse = StartEndpointResponses[keyof StartEndpointResponses];

export type GetEndpointStatusData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/endpoints/{endpoint_id}/status';
};

export type GetEndpointStatusErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type GetEndpointStatusResponses = {
    /**
     * Endpoint status
     */
    200: EndpointStatusInfoResponse;
};

export type GetEndpointStatusResponse = GetEndpointStatusResponses[keyof GetEndpointStatusResponses];

export type StopEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/endpoints/{endpoint_id}/stop';
};

export type StopEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type StopEndpointResponses = {
    /**
     * Endpoint stopped successfully
     */
    200: unknown;
};

export type SetBranchExpirationData = {
    body: SetBranchExpirationRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/expiration';
};

export type SetBranchExpirationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type SetBranchExpirationResponses = {
    /**
     * Branch expiration set successfully
     */
    200: unknown;
};

export type GetLsnByTimestampData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query: {
        /**
         * ISO 8601 timestamp (e.g., 2024-05-06T10:00:00.000Z)
         */
        timestamp: string;
    };
    url: '/projects/{project_id}/branches/{branch_id}/lsn_by_timestamp';
};

export type GetLsnByTimestampErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type GetLsnByTimestampResponses = {
    /**
     * LSN retrieved successfully
     */
    200: LsnByTimestampResponse;
};

export type GetLsnByTimestampResponse = GetLsnByTimestampResponses[keyof GetLsnByTimestampResponses];

export type DeleteBranchProtectionData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/protection';
};

export type DeleteBranchProtectionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch or protection rule not found
     */
    404: unknown;
};

export type DeleteBranchProtectionResponses = {
    /**
     * Branch protection rule deleted
     */
    204: void;
};

export type DeleteBranchProtectionResponse = DeleteBranchProtectionResponses[keyof DeleteBranchProtectionResponses];

export type GetBranchProtectionData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/protection';
};

export type GetBranchProtectionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch or protection rule not found
     */
    404: unknown;
};

export type GetBranchProtectionResponses = {
    /**
     * Branch protection rule
     */
    200: BranchProtectionResponse;
};

export type GetBranchProtectionResponse = GetBranchProtectionResponses[keyof GetBranchProtectionResponses];

export type UpdateBranchProtectionData = {
    body: UpdateBranchProtectionRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/protection';
};

export type UpdateBranchProtectionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch or protection rule not found
     */
    404: unknown;
};

export type UpdateBranchProtectionResponses = {
    /**
     * Branch protection rule updated
     */
    200: BranchProtectionResponse;
};

export type UpdateBranchProtectionResponse = UpdateBranchProtectionResponses[keyof UpdateBranchProtectionResponses];

export type CreateBranchProtectionData = {
    body: CreateBranchProtectionRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/protection';
};

export type CreateBranchProtectionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
    /**
     * Protection rule already exists for this branch
     */
    409: unknown;
};

export type CreateBranchProtectionResponses = {
    /**
     * Branch protection rule created
     */
    201: BranchProtectionResponse;
};

export type CreateBranchProtectionResponse = CreateBranchProtectionResponses[keyof CreateBranchProtectionResponses];

export type ListPublicationsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/publications';
};

export type ListPublicationsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Project or branch not found
     */
    404: unknown;
};

export type ListPublicationsResponses = {
    /**
     * Publications retrieved
     */
    200: PublicationsResponse;
};

export type ListPublicationsResponse = ListPublicationsResponses[keyof ListPublicationsResponses];

export type CreatePublicationData = {
    body: CreatePublicationRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/publications';
};

export type CreatePublicationErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - logical replication not enabled
     */
    403: unknown;
    /**
     * Project or branch not found
     */
    404: unknown;
};

export type CreatePublicationResponses = {
    /**
     * Publication created
     */
    201: PublicationInfoResponse;
};

export type CreatePublicationResponse = CreatePublicationResponses[keyof CreatePublicationResponses];

export type DeletePublicationData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Publication ID
         */
        publication_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/publications/{publication_id}';
};

export type DeletePublicationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Publication not found
     */
    404: unknown;
};

export type DeletePublicationResponses = {
    /**
     * Publication deleted
     */
    204: void;
};

export type DeletePublicationResponse = DeletePublicationResponses[keyof DeletePublicationResponses];

export type UpdatePublicationData = {
    body: UpdatePublicationRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Publication ID
         */
        publication_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/publications/{publication_id}';
};

export type UpdatePublicationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Publication not found
     */
    404: unknown;
};

export type UpdatePublicationResponses = {
    /**
     * Publication updated
     */
    200: PublicationInfoResponse;
};

export type UpdatePublicationResponse = UpdatePublicationResponses[keyof UpdatePublicationResponses];

export type ListReplicationSlotsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/replication-slots';
};

export type ListReplicationSlotsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Project or branch not found
     */
    404: unknown;
};

export type ListReplicationSlotsResponses = {
    /**
     * Replication slots retrieved
     */
    200: ReplicationSlotsResponse;
};

export type ListReplicationSlotsResponse = ListReplicationSlotsResponses[keyof ListReplicationSlotsResponses];

export type CreateReplicationSlotData = {
    body: CreateReplicationSlotRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/replication-slots';
};

export type CreateReplicationSlotErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - logical replication not enabled
     */
    403: unknown;
    /**
     * Project or branch not found
     */
    404: unknown;
};

export type CreateReplicationSlotResponses = {
    /**
     * Replication slot created
     */
    201: ReplicationSlotInfoResponse;
};

export type CreateReplicationSlotResponse = CreateReplicationSlotResponses[keyof CreateReplicationSlotResponses];

export type DeleteReplicationSlotData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Replication slot ID
         */
        slot_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/replication-slots/{slot_id}';
};

export type DeleteReplicationSlotErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Replication slot not found
     */
    404: unknown;
};

export type DeleteReplicationSlotResponses = {
    /**
     * Replication slot deleted
     */
    204: void;
};

export type DeleteReplicationSlotResponse = DeleteReplicationSlotResponses[keyof DeleteReplicationSlotResponses];

export type ResetBranchData = {
    body: ResetBranchRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID to reset
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/reset';
};

export type ResetBranchErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
    /**
     * Not implemented - requires SerenDB WAL integration
     */
    501: unknown;
};

export type ResetBranchResponses = {
    /**
     * Branch reset successfully
     */
    200: BranchResponse;
};

export type ResetBranchResponse = ResetBranchResponses[keyof ResetBranchResponses];

export type RestoreBranchData = {
    body: RestoreBranchRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID to restore
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/restore';
};

export type RestoreBranchErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
    /**
     * Not implemented - requires SerenDB WAL integration
     */
    501: unknown;
};

export type RestoreBranchResponses = {
    /**
     * Branch restored successfully
     */
    200: BranchRestoredResponse;
};

export type RestoreBranchResponse = RestoreBranchResponses[keyof RestoreBranchResponses];

export type ListBranchRolesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/roles';
};

export type ListBranchRolesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type ListBranchRolesResponses = {
    /**
     * List of roles
     */
    200: RoleInfosResponse;
};

export type ListBranchRolesResponse = ListBranchRolesResponses[keyof ListBranchRolesResponses];

export type CreateBranchRoleData = {
    body: CreateRoleRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/roles';
};

export type CreateBranchRoleErrors = {
    /**
     * Bad request - role already exists or invalid parameters
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type CreateBranchRoleResponses = {
    /**
     * Role created successfully
     */
    201: RoleCreatedResponse;
};

export type CreateBranchRoleResponse = CreateBranchRoleResponses[keyof CreateBranchRoleResponses];

export type DeleteBranchRoleData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Role ID
         */
        role_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/roles/{role_id}';
};

export type DeleteBranchRoleErrors = {
    /**
     * Cannot delete protected role
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Role or branch not found
     */
    404: unknown;
};

export type DeleteBranchRoleResponses = {
    /**
     * Role deleted successfully
     */
    200: unknown;
};

export type ResetRolePasswordData = {
    body: ResetRolePasswordRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Role ID
         */
        role_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/roles/{role_id}/reset_password';
};

export type ResetRolePasswordErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Role or branch not found
     */
    404: unknown;
};

export type ResetRolePasswordResponses = {
    /**
     * Password reset successfully
     */
    200: RolePasswordResetResponse;
};

export type ResetRolePasswordResponse = ResetRolePasswordResponses[keyof ResetRolePasswordResponses];

export type DeleteRoleByNameData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Role name
         */
        role_name: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/roles/{role_name}';
};

export type DeleteRoleByNameErrors = {
    /**
     * Cannot delete protected role
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Role or branch not found
     */
    404: unknown;
};

export type DeleteRoleByNameResponses = {
    /**
     * Role deleted successfully
     */
    200: unknown;
};

export type GetRoleByNameData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Role name
         */
        role_name: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/roles/{role_name}';
};

export type GetRoleByNameErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Role or branch not found
     */
    404: unknown;
};

export type GetRoleByNameResponses = {
    /**
     * Role details
     */
    200: RoleInfoResponse;
};

export type GetRoleByNameResponse = GetRoleByNameResponses[keyof GetRoleByNameResponses];

export type ResetRolePasswordByNameData = {
    body: ResetRolePasswordRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Role name
         */
        role_name: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reset_password';
};

export type ResetRolePasswordByNameErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Role or branch not found
     */
    404: unknown;
};

export type ResetRolePasswordByNameResponses = {
    /**
     * Password reset successfully
     */
    200: RolePasswordResetResponse;
};

export type ResetRolePasswordByNameResponse = ResetRolePasswordByNameResponses[keyof ResetRolePasswordByNameResponses];

export type RevealRolePasswordData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Role name
         */
        role_name: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reveal_password';
};

export type RevealRolePasswordErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Role or branch not found
     */
    404: unknown;
};

export type RevealRolePasswordResponses = {
    /**
     * Role password revealed
     */
    200: RolePasswordResetResponse;
};

export type RevealRolePasswordResponse = RevealRolePasswordResponses[keyof RevealRolePasswordResponses];

export type SetDefaultBranchData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/set-default';
};

export type SetDefaultBranchErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type SetDefaultBranchResponses = {
    /**
     * Default branch set successfully
     */
    200: unknown;
};

export type SetDefaultBranchAliasData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/branches/{branch_id}/set_as_default';
};

export type SetDefaultBranchAliasErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type SetDefaultBranchAliasResponses = {
    /**
     * Default branch set successfully
     */
    200: unknown;
};

export type GetTimestampByLsnData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Branch ID
         */
        branch_id: string;
    };
    query: {
        /**
         * Log Sequence Number (e.g., 0/1234567)
         */
        lsn: string;
    };
    url: '/projects/{project_id}/branches/{branch_id}/timestamp_by_lsn';
};

export type GetTimestampByLsnErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Branch not found
     */
    404: unknown;
};

export type GetTimestampByLsnResponses = {
    /**
     * Timestamp retrieved successfully
     */
    200: TimestampByLsnResponse;
};

export type GetTimestampByLsnResponse = GetTimestampByLsnResponses[keyof GetTimestampByLsnResponses];

export type GetProjectConnectionUriData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: {
        /**
         * Branch ID to target (defaults to project's default branch)
         */
        branch_id?: string | null;
        /**
         * Endpoint ID to target (defaults to first endpoint in branch)
         */
        endpoint_id?: string | null;
        /**
         * Database name override (currently ignored)
         */
        database_name?: string | null;
        /**
         * Role name override (currently ignored)
         */
        role_name?: string | null;
        /**
         * Return pooled connection (currently ignored)
         */
        pooled?: boolean | null;
    };
    url: '/projects/{project_id}/connection_uri';
};

export type GetProjectConnectionUriErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project, branch, or endpoint not found
     */
    404: unknown;
};

export type GetProjectConnectionUriResponses = {
    /**
     * Connection URI retrieved
     */
    200: ProjectConnectionUriResponse;
};

export type GetProjectConnectionUriResponse = GetProjectConnectionUriResponses[keyof GetProjectConnectionUriResponses];

export type GetProjectConsumptionData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: {
        /**
         * Optional ISO-8601 start date (YYYY-MM-DD), defaults to first day of current month.
         */
        start_date?: string | null;
        /**
         * Optional ISO-8601 end date (YYYY-MM-DD), defaults to today (UTC).
         */
        end_date?: string | null;
    };
    url: '/projects/{project_id}/consumption';
};

export type GetProjectConsumptionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User is not a member of the organization
     */
    403: unknown;
    /**
     * Project not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetProjectConsumptionResponses = {
    /**
     * Project consumption retrieved
     */
    200: ProjectConsumptionResponse;
};

export type GetProjectConsumptionResponse = GetProjectConsumptionResponses[keyof GetProjectConsumptionResponses];

export type ListProjectDatabasesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/databases';
};

export type ListProjectDatabasesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type ListProjectDatabasesResponses = {
    /**
     * List of all databases in project with context
     */
    200: DatabasesWithContextResponse;
};

export type ListProjectDatabasesResponse = ListProjectDatabasesResponses[keyof ListProjectDatabasesResponses];

export type ListProjectEndpointsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/endpoints';
};

export type ListProjectEndpointsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type ListProjectEndpointsResponses = {
    /**
     * List of endpoints
     */
    200: EndpointsResponse;
};

export type ListProjectEndpointsResponse = ListProjectEndpointsResponses[keyof ListProjectEndpointsResponses];

export type DeleteProjectEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/endpoints/{endpoint_id}';
};

export type DeleteProjectEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type DeleteProjectEndpointResponses = {
    /**
     * Endpoint deleted successfully
     */
    200: unknown;
};

export type UpdateProjectEndpointData = {
    body: UpdateEndpointRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/endpoints/{endpoint_id}';
};

export type UpdateProjectEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type UpdateProjectEndpointResponses = {
    /**
     * Endpoint updated successfully
     */
    200: EndpointResponse;
};

export type UpdateProjectEndpointResponse = UpdateProjectEndpointResponses[keyof UpdateProjectEndpointResponses];

export type RestartProjectEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/endpoints/{endpoint_id}/restart';
};

export type RestartProjectEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type RestartProjectEndpointResponses = {
    /**
     * Endpoint restart initiated
     */
    200: EndpointStatusInfoResponse;
};

export type RestartProjectEndpointResponse = RestartProjectEndpointResponses[keyof RestartProjectEndpointResponses];

export type StartProjectEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/endpoints/{endpoint_id}/start';
};

export type StartProjectEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type StartProjectEndpointResponses = {
    /**
     * Endpoint start initiated
     */
    200: EndpointStatusInfoResponse;
};

export type StartProjectEndpointResponse = StartProjectEndpointResponses[keyof StartProjectEndpointResponses];

export type SuspendProjectEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/endpoints/{endpoint_id}/suspend';
};

export type SuspendProjectEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Endpoint not found
     */
    404: unknown;
};

export type SuspendProjectEndpointResponses = {
    /**
     * Endpoint suspended
     */
    200: unknown;
};

export type ListIpAllowListData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/ip-allow';
};

export type ListIpAllowListErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type ListIpAllowListResponses = {
    /**
     * List of IP allow list entries
     */
    200: IpAllowListsResponse;
};

export type ListIpAllowListResponse = ListIpAllowListResponses[keyof ListIpAllowListResponses];

export type AddIpToAllowListData = {
    body: AddIpAllowListRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/ip-allow';
};

export type AddIpToAllowListErrors = {
    /**
     * Invalid IP address format
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
    /**
     * IP already exists in allow list
     */
    409: unknown;
};

export type AddIpToAllowListResponses = {
    /**
     * IP added to allow list
     */
    201: IpAllowListResponse;
};

export type AddIpToAllowListResponse = AddIpToAllowListResponses[keyof AddIpToAllowListResponses];

export type ResetIpAllowListData = {
    body: ResetIpAllowListRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/ip-allow/reset';
};

export type ResetIpAllowListErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type ResetIpAllowListResponses = {
    /**
     * IP allow list reset successfully
     */
    200: IpAllowListsResponse;
};

export type ResetIpAllowListResponse = ResetIpAllowListResponses[keyof ResetIpAllowListResponses];

export type RemoveIpFromAllowListData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * IP allow list entry ID
         */
        ip_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/ip-allow/{ip_id}';
};

export type RemoveIpFromAllowListErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project or IP entry not found
     */
    404: unknown;
};

export type RemoveIpFromAllowListResponses = {
    /**
     * IP removed from allow list
     */
    204: void;
};

export type RemoveIpFromAllowListResponse = RemoveIpFromAllowListResponses[keyof RemoveIpFromAllowListResponses];

export type ListOperationsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/operations';
};

export type ListOperationsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type ListOperationsResponses = {
    /**
     * List of operations
     */
    200: OperationsResponse;
};

export type ListOperationsResponse = ListOperationsResponses[keyof ListOperationsResponses];

export type GetOperationData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Operation ID
         */
        operation_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/operations/{operation_id}';
};

export type GetOperationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project or operation not found
     */
    404: unknown;
};

export type GetOperationResponses = {
    /**
     * Operation details
     */
    200: OperationResponse;
};

export type GetOperationResponse = GetOperationResponses[keyof GetOperationResponses];

export type GetReplicationSettingsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/replication';
};

export type GetReplicationSettingsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type GetReplicationSettingsResponses = {
    /**
     * Replication settings retrieved
     */
    200: LogicalReplicationSettingsResponse;
};

export type GetReplicationSettingsResponse = GetReplicationSettingsResponses[keyof GetReplicationSettingsResponses];

export type UpdateReplicationSettingsData = {
    body: UpdateLogicalReplicationRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/replication';
};

export type UpdateReplicationSettingsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type UpdateReplicationSettingsResponses = {
    /**
     * Replication settings updated
     */
    200: LogicalReplicationSettingsResponse;
};

export type UpdateReplicationSettingsResponse = UpdateReplicationSettingsResponses[keyof UpdateReplicationSettingsResponses];

export type GetProjectSizeData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/size';
};

export type GetProjectSizeErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type GetProjectSizeResponses = {
    /**
     * Storage size retrieved successfully
     */
    200: ProjectSizeResponse;
};

export type GetProjectSizeResponse = GetProjectSizeResponses[keyof GetProjectSizeResponses];

export type ListProjectVpcEndpointsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/vpc-endpoints';
};

export type ListProjectVpcEndpointsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type ListProjectVpcEndpointsResponses = {
    /**
     * Project VPC endpoint assignments
     */
    200: Array<ProjectVpcEndpointAssignment>;
};

export type ListProjectVpcEndpointsResponse = ListProjectVpcEndpointsResponses[keyof ListProjectVpcEndpointsResponses];

export type AssignProjectVpcEndpointData = {
    body: AssignProjectVpcEndpointRequest;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/vpc-endpoints';
};

export type AssignProjectVpcEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project or VPC endpoint not found
     */
    404: unknown;
};

export type AssignProjectVpcEndpointResponses = {
    /**
     * Project VPC endpoint assignment created
     */
    201: ProjectVpcEndpointAssignmentResponse;
};

export type AssignProjectVpcEndpointResponse = AssignProjectVpcEndpointResponses[keyof AssignProjectVpcEndpointResponses];

export type RemoveProjectVpcEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Project VPC endpoint assignment ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/vpc-endpoints/{assignment_id}';
};

export type RemoveProjectVpcEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Assignment not found
     */
    404: unknown;
};

export type RemoveProjectVpcEndpointResponses = {
    /**
     * Project VPC endpoint assignment removed
     */
    204: void;
};

export type RemoveProjectVpcEndpointResponse = RemoveProjectVpcEndpointResponses[keyof RemoveProjectVpcEndpointResponses];

export type ListProjectVpcEndpointsAliasData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/vpc_endpoints';
};

export type ListProjectVpcEndpointsAliasErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project not found
     */
    404: unknown;
};

export type ListProjectVpcEndpointsAliasResponses = {
    /**
     * Project VPC endpoint assignments
     */
    200: Array<ProjectVpcEndpointAssignment>;
};

export type ListProjectVpcEndpointsAliasResponse = ListProjectVpcEndpointsAliasResponses[keyof ListProjectVpcEndpointsAliasResponses];

export type RemoveProjectVpcEndpointByVpcIdData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Organization VPC endpoint ID
         */
        vpc_endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/vpc_endpoints/{vpc_endpoint_id}';
};

export type RemoveProjectVpcEndpointByVpcIdErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Assignment not found
     */
    404: unknown;
};

export type RemoveProjectVpcEndpointByVpcIdResponses = {
    /**
     * Project VPC endpoint assignment removed
     */
    204: void;
};

export type RemoveProjectVpcEndpointByVpcIdResponse = RemoveProjectVpcEndpointByVpcIdResponses[keyof RemoveProjectVpcEndpointByVpcIdResponses];

export type AssignProjectVpcEndpointByIdData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Organization VPC endpoint ID
         */
        vpc_endpoint_id: string;
    };
    query?: never;
    url: '/projects/{project_id}/vpc_endpoints/{vpc_endpoint_id}';
};

export type AssignProjectVpcEndpointByIdErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Project or VPC endpoint not found
     */
    404: unknown;
};

export type AssignProjectVpcEndpointByIdResponses = {
    /**
     * Project VPC endpoint assignment created
     */
    201: ProjectVpcEndpointAssignmentResponse;
};

export type AssignProjectVpcEndpointByIdResponse = AssignProjectVpcEndpointByIdResponses[keyof AssignProjectVpcEndpointByIdResponses];

export type ListSessionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sessions';
};

export type ListSessionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListSessionsResponses = {
    /**
     * Sessions retrieved successfully
     */
    200: Array<Session>;
};

export type ListSessionsResponse = ListSessionsResponses[keyof ListSessionsResponses];

export type RevokeAllSessionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sessions/revoke-all';
};

export type RevokeAllSessionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type RevokeAllSessionsResponses = {
    /**
     * All sessions revoked successfully
     */
    200: SessionsRevokedResponse;
};

export type RevokeAllSessionsResponse = RevokeAllSessionsResponses[keyof RevokeAllSessionsResponses];

export type RevokeSessionData = {
    body?: never;
    path: {
        /**
         * Session ID to revoke
         */
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}';
};

export type RevokeSessionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Session not found
     */
    404: unknown;
};

export type RevokeSessionResponses = {
    /**
     * Session revoked successfully
     */
    200: SessionsRevokedResponse;
};

export type RevokeSessionResponse = RevokeSessionResponses[keyof RevokeSessionResponses];

export type RevokeOtherSessionsData = {
    body?: never;
    path: {
        /**
         * Session ID to keep (current session)
         */
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}/revoke-others';
};

export type RevokeOtherSessionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Session not found or doesn't belong to user
     */
    404: unknown;
};

export type RevokeOtherSessionsResponses = {
    /**
     * Other sessions revoked successfully
     */
    200: SessionsRevokedResponse;
};

export type RevokeOtherSessionsResponse = RevokeOtherSessionsResponses[keyof RevokeOtherSessionsResponses];

export type ListEventTypesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/webhooks/event-types';
};

export type ListEventTypesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListEventTypesResponses = {
    /**
     * Event types retrieved successfully
     */
    200: Array<string>;
};

export type ListEventTypesResponse = ListEventTypesResponses[keyof ListEventTypesResponses];

export type HandleStripeWebhookData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/webhooks/stripe';
};

export type HandleStripeWebhookErrors = {
    /**
     * Invalid webhook signature
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type HandleStripeWebhookResponses = {
    /**
     * Webhook processed
     */
    200: unknown;
};
