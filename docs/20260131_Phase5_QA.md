# Seren Browser Phase 5 QA & Security Review (January 31, 2026)

## Verdict
The OpenClaw phase is now much closer to shippable, but it still falls short on stability and security hardening. The Node runtime finally exposes the required RPC handlers, and the SPA can start/stop OpenClaw and receive events. However, several critical gaps remain: the installer cannot provision OpenClaw, trust/approval UX still fails silently, and there is no recovery path if the binary is missing or crashes repeatedly. Phase 5 should remain blocked until these issues are resolved.

## What Works Now
- Runtime handlers for all OpenClaw commands are present (`runtime/src/handlers/openclaw.ts:278-556`) and registered in the JSON‑RPC router (`runtime/src/handlers/index.ts:43-57`).
- The runtime emits events (`openclaw://status-changed`, `openclaw://channel-event`, `openclaw://message-received`) through the shared event bus (`runtime/src/events.ts`), allowing the SPA store/listeners to react.
- The browser bridge now authenticates to the runtime via token exchange (`src/lib/bridge.ts:65-160`), so RPC calls succeed once the daemon is running.

## Remaining Functional Gaps
1. **No automated provisioning of the OpenClaw binary (Blocker)** – The runtime searches for `openclaw.mjs` under `~/.seren/lib/node_modules/openclaw`, `~/.openclaw/openclaw.mjs`, or `$PATH` (`runtime/src/handlers/openclaw.ts:145-176`) but never installs it. Phase 5 promised “OpenClaw via Local Runtime,” yet the install scripts (`scripts/install.sh/.ps1`) only add `@serendb/runtime`. On a fresh machine, `openclaw_start` always throws “OpenClaw not found,” leaving users with an inoperable feature.
2. **Hook token and config files are written in plaintext without guidance (Major)** – `hookToken` is persisted to `~/.openclaw/openclaw.json` with mode 0600, but the installer never informs users about this sensitive secret, nor does it integrate with OS keyrings. Losing control of that file gives attackers command-level access to all connected channels.
3. **Channel management assumes platform-specific credentials without validation (Major)** – `openclawConnectChannel()` blindly writes whatever the UI passes into the OpenClaw config (`runtime/src/handlers/openclaw.ts:386-452`). There is no validation, encryption, or masking of secrets (Signal phone numbers, Discord tokens, Slack app tokens). The SPA also never redacts those values in logs (e.g., `src/services/openclaw-agent.ts` still logs channel info), so secrets can leak through consoles.
4. **Approval UX still breaks for trust-required channels (Major)** – Although the runtime now enforces approval via `openclawGrantApproval` (`runtime/src/handlers/openclaw.ts:515-551`), the SPA’s approval dialog (`src/components/settings/OpenClawApproval.tsx:34-66`) fires only when the runtime emits `openclaw://approval-needed`. The runtime never emits that event: `openclawSend()` simply throws “Message requires approval” (line 504) without emitting the event. The result is a hard failure instead of a guided approval workflow.
5. **Crash recovery lacks backoff visibility (Minor)** – When OpenClaw crashes, the runtime auto‑restarts up to three times (`runtime/src/handlers/openclaw.ts:205-264`) but never surfaces restart attempts or errors to the UI beyond a generic “crashed” status. Users can’t see why the restart failed or how to fix missing dependencies.

## Security Concerns
- **OpenClaw binary source is unverified:** the runtime will execute whichever `openclaw` executable appears first in `PATH`, opening the door for malicious binaries. Phase 5 needs checksum verification or a pinned download source.
- **HTTP hook endpoint listens unauthenticated beyond bearer token:** if another local process learns the persisted hook token (stored in plaintext), it can impersonate the SPA and send arbitrary messages.

## Recommendations Before Sign-off
1. Extend the installer to download and install a vetted OpenClaw release (matching OS/arch) so users aren’t left hunting for `openclaw.mjs` manually.
2. Emit `openclaw://approval-needed` events from the runtime whenever `openclawSend()` encounters a trust-required message, and ensure the SPA surfaces the approval UI with clear success/error states.
3. Validate and sanitize channel credentials server-side; avoid logging secrets, and consider encrypting sensitive data at rest.
4. Surface restart/backoff telemetry to the UI (e.g., include `restartCount` and last error in the `openclaw_status` response) so users understand why the process isn’t running.
5. Add integration tests covering start → channel connect → message send, including the approval path and crash/restart flows.

Once these gaps are addressed and verified (with automated tests where possible), Phase 5 can move toward production readiness.
